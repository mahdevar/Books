\documentclass[openany, twocolumn]{book}
\input{preamble/main.tex}
\begin{document}
\frontmatter
\title{زبان پایتون}
\author{مهدور}

\maketitle
\mainmatter

\chapter{❬پریریکویزیت ها❭}
بهتر است پیش از پرداختن به ‹پایتون› کمی با ‹الگوریتم› و ‹فلوچارت› آشنا شد•

\section{❬الگوریتم❭}
به سادگی، ‹الگوریتم› ‹سیکونس› ‹کامند هایی› است که برای ‹اگزکیوت› یک ‹پروسه› یا رسیدن به ‹ریسپانس› یک ‹کوسشن› نوشته شده است• ‹الگوریتم› بیرون رفتن از دانشگاه و ‹الگوریتم› یافتن یک ‹استیودنت› دو ‹اینستنس› هستند•

یک ‹الگوریتم›، همان گونه که \ref{R0} نشان می‌دهد، باید بر ‹بیس› ‹دیتا ها› یا داشته‌های خود به ‹ریسپانس› برسد• برای ‹اینستنس› ‹الگوریتم› یافتن بهتر‌ین ‹استیودنت› باید ‹نییم› و ‹اوریج› ‹استیودنت ها› را گرفته و ‹نییم› بهتر‌ین آنها را ‹ریترن کند›• (‹دولوپ› ‹الگوریتم› ‹پروسه ی› است که نیاز به آموزش دارد• در اینجا به ‹متد های› ‹فاندامنتال› ‹دولوپ› ‹الگوریتم ها› نمی‌پردازیم•)

پس از نوشتن یک ‹الگوریتم› بهتر است آن را ‹ایمپلیمنت› کرد•
\begin{quotation}
‹ایمپلیمنت› نوشتن ‹الگوریتم› با یک ‹لنگویج› ‹پروگرامینگ› مانند ‹پایتون› است•
\end{quotation}
پس از ‹ایمپلیمنت› می‌توان از یک دستگاه مانند ‹موبایل› خواست تا ‹پروگرام› را ‹اگزکیوت کند›•

\begin{Figure}
\begin{tikzpicture}
	\matrix
	{
		|(I)[object]|❬دیتا ها❭&|(A)[activity]|❬الگوریتم❭&|(O)[object]|❬ریسپانس❭\\
	}; 
	{[edges]
		\draw (I) -- (A);
		\draw (A) -- (O);
	}
\end{tikzpicture}

\caption{❬الگوریتم❭ ❬پت❭ رسیدن به ❬ریسپانس❭ از روی ❬دیتا ها❭ است\label{R0}}
\end{Figure}

\section{❬فلوچارت❭}
یک ‹الگوریتم› را می‌توان با هر ‹لنگویج ـی› نوشت؛ اما ‹لنگویج› ‹فلوچارت› ‹سجست› می‌شود؛ زیرا این ‹لنگویج› ساده است و بسیاری آن را ‹یوتیلایز میکنند›• ‹لنگویج› ‹فلوچارت› ‹سیمبول های› \ref{R1} را دارد• در چند ‹فلوچارت› پیش رو ‹متد› ‹یوتیلایز› ‹سیمبول ها› آورده شده است•

\begin{Table}
\caption{❬سیمبول های❭ ❬لنگویج❭ ❬فلوچارت❭\label{R1}}

\begingroup
\tikzset{baseline={([yshift=-2ex]current bounding box.north)}}

\begin{tabular}{2۸}
\RLE{‹سیمبول›} & ‹فانکشنالیتی›\\
\tikz\draw [edges] (0, 0) -- (5em,  0); & ‹پت ـی› که باید پیموده شود را نشان می‌دهد• همواره باید یک و تنها یک ‹پت› پیش رو باشد!\\
\tikz\node [terminator] {}; & این ‹سیمبول› آغاز و پایان ‹الگوریتم› را نشان می‌دهد• هر ‹الگوریتم› یک و تنها یک ‹سیمبول› آغاز و پایان باید داشته باشد•\\
\tikz\node [computation] {}; & ‹پروسس ها› در این ‹سیمبول› نوشته می‌شوند• می‌توان چندین ‹پروسس› را درون یکی از این‌ها نوشت•\\
\tikz\node [input] {}; & برای دریافت ‹دیتا ها› این ‹سیمبول› را باید کشید• می‌توان ‹نییم› چند ‹آیدنتیفایر› را درون یکی از اینها نوشت•\\
\tikz\node [output] {}; & برای نشان دادن ‹ریسپانس› به ‹یوزر›\EndNote{‹یوزر› کسی است که ‹الگوریتم› را ‹تریس› می‌کند تا به ‹ریسپانس› برسد•} از این ‹سیمبول› کمک گرفته می‌شود•\\
\tikz\node [decision] {}; & برای ‹اگزکیوت› کار‌های گوناگون بر ‹بیس› ‹ترو› یا ‹فالس› بودن یک ‹استاتمنت› یا ‹کاندیشن› این ‹سیمبول› آورده می‌شود•\\
\end{tabular}

\endgroup
\end{Table}

\ref{R2} مساحت و محیط یک مربع را نشان می‌دهد: طول ضلع، $L$، از ‹یوزر› گرفته شده، مساحت و محیط آن، $A$ و $C$، نشان داده می‌شوند•

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		|(S)[terminator]|Start&|(C)[computation]|$A\gets L^2$&|(D)[output]|$A,C$\\
		|(A)[input]|$L$&|(B)[computation]|$C\gets 4L$&|(E)[terminator]|End\\
	}; 
	{[edges]
		\draw (S) -- (A);
		\draw (A) -- (B);
		\draw (B) -- (C);
		\draw (C) -- (D);
		\draw (D) -- (E);
	}
\end{tikzpicture}

\caption{نشان دادن مساحت و محیط یک مربع\label{R2}}
\end{Flowchart}

در \ref{R3} که ‹متد› ‹یوتیلایز› ‹سیمبول› ‹کاندیشن› را نشان می‌دهد اگر $x<0$ باشد یک ‹پت› و اگر نباشد ‹پت› دیگری پیموده می‌شود• این ‹فلوچارت› $x$ را از ‹یوزر› گرفته، $\left|x\right|$ را بدست آورده و ‹پرینت› می‌کند•

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		&|(S)[terminator]|Start\\
		&|(I)[input]|$x$\\
		|(Y)[computation]|$y\gets-x$&|(D)[decision]|$x<0$&|(N)[computation]|$y\gets+x$\\
		&|(O)[output]|$y$\\
		&|(E)[terminator]|End\\
	};
	{[edges]
		\draw (S) -- (I);
		\draw (I) -- (D);
		\draw (D) -- node {بله} (Y);
		\draw (D) -- node {خیر} (N);
		\draw (Y) |- (O);
		\draw (N) |- (O);
		\draw (O) -- (E);
	}
\end{tikzpicture}

\caption{بدست آوردن $\left|x\right|$\label{R3}}
\end{Flowchart}

در یک ‹فلوچارت› می‌توان یک ‹سیمبول› را چندین بار ‹یوتیلایز کرد›• برای ‹اینستنس› در \ref{R4} یک ‹سیمبول› ده بار ‹یوتیلایز شده›• اما برای ‹اگزکیوت› برخی ‹پروسس ها› نمی‌توان با چند بار کشیدن یک ‹سیمبول› کار را پیش برد• برای ‹اینستنس› نمی‌توان با این ‹متد› از $1$ تا $1000$ را نمایش داد؛ زیرا باید یک ‹سیمبول› را $1000$ بار نوشت!

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		|(I)[input]|$D$&|(S)[terminator]|Start&|(E)[terminator]|End\\
		|(D0)[decision]|$D=0$&|(O0)[output]|صفر\\
		|(D1)[decision]|$D=1$&|(O1)[output]|یک\\
		|(N1)|\large$\vdots$&|(N2)|\large$\vdots$\\
		|(D9)[decision]|$D=9$&|(O9)[output]|نه\\
		&|(ON)[output]|شما یک ❬دیجیت❭ ندادید!\\
	};
	{[edges]
		\draw (S) -- (I);
		\draw (I) -- (D0);
		\draw (O0) -| (E.240);
		\draw (O1) -| (E.260);
		\draw (O9) -| (E.280);
		\draw (ON) -| (E.300);
		\draw (D0) -- node {بله} (O0);
		\draw (D1) -- node {بله} (O1);
		\draw (D9) -- node {بله} (O9);
		\draw (D0) -- node {خیر} (D1);
		\draw (D1) -- node {خیر} (N1);
		\draw (N1) -- node {خیر} (D9);
		\draw (D9) -- node [anchor=west] {خیر} +(0, -5em) |- (ON);
	}
\end{tikzpicture}

\caption{یافتن برابر ❬استرینگ ای❭ یک ❬دیجیت❭\label{R4}}
\end{Flowchart}

در یک ‹فلوچارت› ‹لوپ› هم می‌توان داشت• برای ‹اینستنس› این ‹کامپوننت› ‹فلوچارت› \begin{tikzpicture}
	\matrix
	{
		|(S)[junction]|&|(O)[activity]|❬کامند ها❭\\
	};
	{[edges]
		\draw (S) -- (O);
		\draw (O.east) -| +(1.75em, 4.25em) -| (O.north);
	}
\end{tikzpicture} یک ‹لوپ› دارد اما ‹یوسابل› نیست زیرا برای همیشه ‹کامند ها› را ‹اگزکیوت میکند› و هیچگاه پایان نمی‌یابد! ‹لوپ ای› که تا زمان ‹ترو› بودن یک ‹استاتمنت› یا ‹کاندیشن› ‹کامند ها› را ‹اگزکیوت میکند› بسیار ‹یوزیج› دارد• این ‹کامپوننت› ‹فلوچارت› \begin{tikzpicture}
	\matrix
	{
		|(S)[junction]|&|(O)[activity]|❬کامند ها❭&|(D)[decision]|❬استاتمنت❭ یا ❬کاندیشن❭\\
		&&|(E)[junction]|\\
	};
	{[edges]
		\draw (O) -- (D);
		\draw (S) -- (O);
		\draw (D.north) -- node {❬ترو❭} +(0, 2em) -| (O.north);
		\draw (D) -- node {❬فالس❭} (E);
	}
\end{tikzpicture} ‹کامند ها› را ‹اگزکیوت میکند› و اگر ‹استاتمنت› پس از آنها ‹ترو› باشد، آنگاه باز هم این کار را ‹اگزکیوت میکند›• این ‹کامپوننت› ‹فلوچارت› \begin{tikzpicture}
	\matrix
	{
		|(S)[junction]|&|(D)[decision]|❬استاتمنت❭ یا ❬کاندیشن❭&|(O)[activity]|❬کامند ها❭\\
		&|(E)[junction]|\\
	};
	{[edges]
		\draw (S) -- (D);
		\draw (D) -- node {❬ترو❭} (O);
		\draw (D) -- node {❬فالس❭} (E);
		\draw (O.north) -- +(0, 2.5em) -| (D.north);
	}
\end{tikzpicture} هم کم و بیش همان کار را ‹اگزکیوت میکند› اما ‹یوزیج› بسیار بیشتری دارد• این بار اگر ‹استاتمنت› ‹ترو› باشد ‹کامند ها› ‹اگزکیوت میشوند› و پس از آن ‹ترو› بودن ‹استاتمنت› دو‌باره بررسی می‌شود• می‌توان دید که اگر ‹استاتمنت› ‹فالس› باشد، ‹کامند ها› یک بار هم ‹کال نمیشوند›!

\ref{R5} که $\sum_{i\gets1}^{10}i^{2}$ را بدست می‌آورد هم یک ‹لوپ› دارد که ‹هایلایت› شده است• در آغاز این ‹فلوچارت› $s\gets0$ و $i\gets1$ می‌شود• پس از آن در یک ‹لوپ› توان دوم $i$ به $s$ و $1$ به $i$ افزوده می‌شود• در پایان ‹لوپ› اگر $i\le10$ باشد، کار‌ها از سر گرفته می‌شوند؛ اگر نه، $i$ ‹پرینت› شده و ‹فلوچارت› پایان می‌یابد•

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		|(S)[terminator]|Start&|(C1)[computation]|{$i\gets 1$\\$s\gets 0$}\\
		&|(D)[decision]|$i\le10$&|(O)[output]|$s$\\
		|(C3)[computation]|$i\gets i+1$&|(C2)[computation]|$s\gets s+i^2$&|(E)[terminator]|End\\
	};
	{[edges]
		\draw (S) -- (C1);
		\draw (C1) -- (D);
		\draw (C2) -- (C3);
		\draw (C3) |- (D);
		\draw (D) -- node {خیر} (O);
		\draw (O) -- (E);
		\draw (D) -- node {بله} (C2);
	}
	{[highlights]
		\node (F) [fit=(D)(C2)(C3)] {};
	}
\end{tikzpicture}

\caption{بدست آوردن $\sum_{i\gets1}^{10}i^{2}$\label{R5}}
\end{Flowchart}

\ref{R6} ‹فاکتوریل› $n$ را نشان می‌دهد• در آغاز $n$ از ‹یوزر› گرفته، $f$ و $i$ برابر با $1$ می‌شوند• پس از آن در یک ‹لوپ› تا هنگامی که $i\le n$ است، $f$ هر بار $i$ برابر شده و یکی به $i$ افزوده می‌شود• پس $f$ که در آغاز برابر با $1$ است در پایان برابر با $1\times1\times2\times\ldots\times n$ خواهد بود•

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		|(I)[input]|$n$&|(C1)[computation]|{$f\gets 1$\\$i\gets 1$}\\
		|(S)[terminator]|Start&|(C2)[computation]|{$f\gets f\!\times i$\\$i\gets i+1$}&|(E)[terminator]|End\\
		&|(D)[decision]|$i\le{n}$&|(O)[output]|$f$\\
	};
	{[edges]
		\draw (D) -- node {خیر} (O);
		\draw (D.west) -- node {بله} +(-1.5em, 0) |- (C2.west);
		\draw (S) -- (I);
		\draw (I) -- (C1);
		\draw (C1) -- (C2);
		\draw (C2) -- (D);
		\draw (O) -- (E);
	}
\end{tikzpicture}

\caption{بدست آوردن ❬فاکتوریل❭\label{R6}}
\end{Flowchart}

برای ‹تستینگ› یک ‹فلوچارت› باید آن را ‹تریس› کرد یا ‹اگزکیوت کرد›• اگر برای ‹اینستنس› ‹یوزر› $4$ را بدهد، آنگاه $f$، $i$، و $n$ تا رسیدن به پایان ‹فلوچارت› و نشان دادن $24$ به ‹یوزر› آنگونه که در \ref{R7} آمده بیشتر می‌شوند•

\begin{Table}
\caption{❬تریس❭ ❬فلوچارت❭ ❬فاکتوریل❭، زمانی که ❬یوزر❭ $4$ را می‌دهد\label{R7}}

\begin{tabular}{TTT}
$n$ & $i$ & $f$\\
$4$ & $1$ & $1$\\
$4$ & $2$ & $1$\\
$4$ & $3$ & $2$\\
$4$ & $4$ & $6$\\
$4$ & $5$ & $24$\\
\end{tabular}
\end{Table}

\ref{R8} ‹متد› بدست آوردن $a^{b}$ را نشان می‌دهد: در آغاز $p$ برابر با $1$ است؛ سپس در یک ‹لوپ› $b$ بار $p$ برابر با $p\times a$ می‌شود• در پایان $p$ برابر با $1\times a\times a\times\ldots\times a=a^{b}$ خواهد بود•

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		|(I)[input]|$a,b$&|(C1)[computation]|{$p\gets 1$\\$i\gets 1$}\\
		|(S)[terminator]|Start&|(D)[decision]|$i\le{b}$&|(O)[output]|$p$\\
		&|(C2)[computation]|{$p\gets p\times a$\\$i\gets i+1$}&|(E)[terminator]|End\\
	};
	{[edges]
		\draw (S) -- (I);
		\draw (I) -- (C1);
		\draw (C1) -- (D);
		\draw (D) -- node {خیر} (O);
		\draw (D) -- node {بله} (C2);
		\draw (C2.west) -| +(-1.5em, 0) |- (D.west);
		\draw (O) -- (E);
	}
\end{tikzpicture}

\caption{بدست آوردن $a^{b}$\label{R8}}
\end{Flowchart}

\ref{R9} ‹نامبر هایی› که $n$ بر آنها ‹پارت› می‌شود را نشان می‌دهد• در این ‹فلوچارت› $i\gets2$ می‌شود• اگر $n\bmod i=0$ باشد آنگاه $i$ ‹پرینت› می‌شود، اگر نه کاری ‹اگزکیوت نمیشود›• سپس $i\gets i+1$ می‌شود و اگر $i<n$ باشد $i$ دو‌باره بررسی می‌شود•

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		|(I)[input]|$n$&|(C1)[computation]|$i\gets 2$\\
		|(S)[terminator]|Start&|(D1)[decision]|$i<n$&|(E)[terminator]|End\\
		&|(D2)[decision]|$n\bmod i=0$&|(O)[output]|$i$\\
		&|(C2)[computation]|$i\gets i+1$\\
	};
	{[edges]
		\draw (S) -- (I);
		\draw (I) -- (C1);
		\draw (C1) -- (D1);
		\draw (D2) -- node {بله} (O);
		\draw (O) |- (C2);
		\draw (D2) -- node {خیر} (C2);
		\draw (D1) -- (D2);
		\draw (D1) -- node {بله} (D2);
		\draw (D1) -- node {خیر} (E);
		\draw (C2.west) -| +(-1.5em, 0) |- (D1.west);
	}
\end{tikzpicture}

\caption{نشان دادن ❬نامبر های❭ ❬پارت کننده❭ $n$\label{R9}}
\end{Flowchart}

\ref{R10} $A$، $B$، و $C$ را از ‹یوزر› گرفته، اگر بتوان با آنها یک مثلث ‹دولوپ کرد› «بله» ، و اگر نتوان «خیر» را نشان می‌دهد•

\begin{Flowchart*}
\begin{tikzpicture}
	\matrix
	{
		|(S)[terminator]|Start&|(I)[input]|$A, B, C$&|(D)[decision]|{\scriptsize$A<B+C$\\and\\$B<A+C$\\and\\$C<A+B$}&|(Y)[output]|بله\\
		&&|(N)[output]|خیر&|(E)[terminator]|End\\
	};
	{[edges]
		\draw (S) -- (I);
		\draw (I) -- (D);
		\draw (D) -- node {بله} (Y);
		\draw (D) -- node {خیر} (N);
		\draw (Y) -- (E);
		\draw (N) -- (E);
	}
\end{tikzpicture}

\caption{آیا می‌توان مثلث کشید\label{R10}}
\end{Flowchart*}

\chapter{❬اتربیوت های❭ ❬پایتون❭}
در ‹پایتون› ‹کامند های› یک ‹پروگرام› یکی پس از دیگری ‹کال شده› و کار می‌کنند• پس اگر ‹کامند ی› نا‌درست باشد، آنگاه ‹پروگرام› تا آن ‹کامند› پیش می‌رود• این ‹اتربیوت› ‹پایتون› ‹اتربیوت های› دیگری را پدید می‌آورد• در اینجا با چندین ‹اتربیوت› برتر این ‹لنگویج› آشنا می‌شویم•

\section{نوشتن با ❬پایتون❭ ساده است}
برای ‹پروگرامر هاـی› که با یک ‹لنگویج› دیگر کار کرده‌اند، ‹لرنینگ› ‹پایتون› آسان است• ‹کامند های› دیگر ‹لنگویج ها› در ‹پایتون› هم هستند، اما ساده‌تر شده‌اند• برای ‹اینستنس› در ‹پایتون› ‹آیدنتیفایر ها› می‌توانند هر چیزی مانند ‹نامبر›، ‹استرینگ›، و \ldots{} را نشان دهند• پس ‹انتری های› یک ‹لیست› هم می‌تواند هر چیزی باشند و یک ‹فانکشن› هم می‌تواند کم و بیش هر چیزی را بپذیرد•

‹پایتون› از ‹متد› «‹پروگرامینگ› ‹اجایل›» ‹ساپورت› می‌کند؛ پس با ‹پایتون› می‌توان یک ‹پروگرام› را با ‹اجایل ـی› ‹دولوپ کرد›• یک ‹پروگرام› نوشته شده با ‹پایتون› کم و بیش یک پنجم همان ‹پروگرام› با ‹سی-پی-پی› ‹کامند› دارد؛ نوشتنش نیز یک پنجم زمان می‌خواهد•

\section{❬پایتون❭ ❬ریدابلیتی❭ بالایی دارد}
داشتن ‹ریدابلیتی› بالا از دیگر برتری‌های ‹پایتون› است• نه تنها ‹کامپیوتر›، ‹آتر› ‹پروگرام›، کسانی که آن را ‹ایمپرو› می‌دهند، و کسانی که از آن ‹ماینتینس› می‌کنند باید ‹پروگرام› را بخوانند• سادگی و ‹ریدابلیتی› می‌تواند به همه اینها کمک کند•

‹پایتون› ‹ریدابلیتی› بسیار خوبی دارد• برای ‹اینستنس› در ‹پایتون› ‹کامند هایی› که درون یک ‹کامند› دیگر یا یک ‹فانکشن› هستند کمی جلو‌تر نوشته می‌شوند و مانند ‹سی-پی-پی› نیاز نیست \code{\{\}} نوشته شود• این ‹ایندنشن ها›، همان گونه که در \ref{R11} می‌توان دید، ‹ریدابلیتی› ‹پروگرام› را بیشتر می‌کنند•

\begin{Program}
\caption{❬ریدابلیتی❭ ❬پایتون❭ در برابر ❬سی-پی-پی❭\label{R11}}

دو ‹فانکشن› زیر یک کار را ‹اگزکیوت میکنند›، اما یکی با ‹پایتون› و دیگری با ‹سی-پی-پی› نوشته شده است•

‹پایتون› \argument{x}\function{abs}\local{y}
▼
def abs(x):
	if x < 0:
		y = -x
	else:
		y = x
	return y
▲
 ‹سی-پی-پی› \lstset{language=cpp}\argument{x}\function{abs}\local{y}
▼
float abs(float x)
{
	float y;
	if(x < 0)
	{
		y = -x;
	}
	else
	{
		y = x;
	}
	return y;
}
▲
 می‌توان دید ‹پروگرام› نوشته شده به ‹پایتون› کوتاه‌تر بوده و ‹ریدابلیتی› بیشتری نیز دارد•
\end{Program}

\section{❬پایتون❭ برای ❬اگزکیوت❭ هر کاری آماده است یا به سادگی آماده می‌شود}
این ‹لنگویج› چندین ‹لایبرری› یا ‹پکیج› دارد که با کمک آنها می‌توان کم و بیش هر ‹پروگرام ای› را نوشت• بسیاری از ‹پکیج ها› را ‹پایتون› از پیش دارد و اگر نیاز باشد می‌توان ‹پکیج های› دیگر را نیز از ‹اینترنت› گرفت• برای ‹اینستنس› می‌توان به سادگی یک ‹دیتابیس› ‹دولوپ کرد› و با آن کار کرد• همچنین ‹پایتون› ‹پکیج هایی› برای ‹دولوپ› ‹وب سایت› و ‹وب سرویس› نیز دارد•

\section{❬پایتون❭ چند ❬پلتفورم ـیی❭ است}
‹پایتون› یک ‹لنگویج› چند ‹پلتفورم ـیی› بسیار خوب است• ‹پروگرام های› نوشته شده با این ‹لنگویج› روی ‹پلتفورم های› ‹ویندوز›، ‹مَک›، ‹لینوکس›، ‹یونیکس›، و \ldots{} کار می‌کنند• هر ‹پلتفورم ـی› که برای آن ‹اینترپرتر› ‹پایتون› ‹دولوپ شده› باشد ‹پروگرام های› نوشته با ‹پایتون› را می‌پذیرد•

\section{❬پایتون❭ در چه چیز‌هایی خوب نیست}
‹پایتون› ‹اینترپرتر› دارد، پس ‹پروگرام های› نوشته شده با آن، به ویژه اگر ‹پروسس های› سنگینی داشته باشند، در برابر ‹لنگویج هایی› مانند ‹سی-پی-پی› کمی کند‌تر پیش می‌روند• خوشبختانه، می‌توان در یک ‹پروگرام› ‹پروسس هایی› که در آنها ‹پایتون› کند است را با ‹لنگویج ـی› مانند ‹سی-پی-پی› نوشت!

در ‹پایتون› ‹آیدنتیفایر ها› ‹لیبل ـی› برای ‹استرینگ ها›، ‹نامبر ها›، ‹لیست ها›، و \ldots{} هستند• پس یک ‹آیدنتیفایر› می‌تواند هر گونه ‹دیتا ای› را نشان دهد! از این رو ‹پایتون› نمی‌تواند در یافتن ‹آیدنتیفایر هایی› که ‹ولیو ـی› از گونه نا‌درست دارند به ‹پروگرامر› کمک کند• برای ‹اینستنس› پس از نوشتن ‹کامند› \code{P = 3.14} ‹آیدنتیفایر› \code{P} برابر با \code{3.14} است؛ اما پس از نوشتن \code{P = "Hello"} همان ‹آیدنتیفایر› \code{P} یک ‹استرینگ› را نشان می‌دهد و ‹کامند› \code{I = sin(P)} نا‌درست می‌شود•

\chapter{آشنایی با ❬پایتون❭}

\section{❬فانکشن هایی❭ برای دریافت ❬دیتا ها❭ و ❬ریپرزنتیشن❭ ❬ریسپانس ها❭}
بهتر است پیش از هر چیز دیگری با ‹فانکشن های› \code{input} و \code{print} ‹پایتون› آشنا شد• با کمک این دو می‌توان ‹دیتا ها› را از ‹یوزر› گرفت و ‹ریسپانس› ‹پروگرام› را به او نشان داد•

\subsection{❬فانکشن❭ \code{input}}
‹فانکشن› \code{input} ‹پروگرام› را نگه می‌دارد تا ‹یوزر› یک ‹استرینگ› بنویسد• برای ‹اینستنس›، ‹کامند› 
▼
I = input()
▲
 یک ‹استرینگ› از ‹یوزر› دریافت کرده و آن را درون ‹آیدنتیفایر› \code{I} می‌گذارد• همچنین اگر ‹استرینگ ای› را به این ‹فانکشن› بدهیم، آن ‹استرینگ› پیش از دریافت ‹دیتا› از ‹یوزر› ‹پرینت› می‌شود•

‹فانکشن› \code{input} همواره ‹استرینگ› ‹ریترن میکند› اما در \ref{R14} ‹متد هایی› برای بدست آوردن یک ‹نامبر› از روی یک ‹استرینگ› آمده است• برای ‹اینستنس›، ‹کامند› 
▼
I = float(input("«قد␣خود␣را␣بنویسید»"))
▲
 یک ‹استرینگ› گرفته و برابر ‹دسیمال› آن را در \code{I} می‌گذارد•

\subsection{❬فانکشن❭ \code{print}}
از سوی دیگر، ‹فانکشن› \code{print} می‌تواند هر چیزی را به ‹یوزر› نشان دهد• برای ‹اینستنس›، ‹کامند› \code{print(2 + 2)} به ‹یوزر› {\beginL \code{4}\endL} را نشان می‌دهد• همچنین با یک \code{print} می‌توان چند ‹ریسپانس› را ‹پرینت› کرد• برای ‹اینستنس›، ‹کامند› \code{print("2+2 =", 2 + 2)} به ‹یوزر› \code{2+2 = 4} را نشان می‌دهد• در \ref{R12} پس از گرفتن ‹نییم› ‹یوزر› به او خوش آمد گفته می‌شود•

\begin{Program}
\caption{❬یوتیلایز❭ ❬فانکشن های❭ \code{print} و \code{input}\label{R12}}
‹ریسپانس› این ‹پروگرام› 
▼
N = input("«نام␣خود␣را␣بنویسید:»")
print("«خوش␣آمدی»", N)
▲
 می‌تواند اینگونه 
⧩
«\em{آرش}» «نام خود را بنویسید:»
«خوش آمدی آرش»
◮
 باشد•
\end{Program}

\section{❬کامنت ها❭}
آنچه پس از ‹کاراکتر› \code{#} آمده ‹کامنت› و برای ‹نالج› ‹پروگرامر ها› یا خوانندگان ‹پروگرام› است• برای ‹اینستنس› در این ‹کامند› 
▼
P = 355 / 113 # «این برآورد بسیار خوبی از $\pi$ است!»
▲
 یک ‹کامنت› نوشته شده است• نوشتن ‹کامنت› برای هر ‹پارت› از ‹پروگرام› ‹رید› آن را ساده‌تر کرده و به ‹پروگرامر ها› کمک می‌کند• این ‹پروگرام› 
▼
# The first two Fibonacci terms are 0 and 1
A, B = 0, 1
# Computing the third term
C = A + B
▲
 دو ‹کامنت› دارد که به خواننده کمک می‌کند ‹فانکشنالیتی› هر ‹کامند› را بداند•

در ‹پایتون› ‹کامنت› چند ‹روو ی› هم می‌توان داشت: به سادگی، باید ‹کامنت› را درون \code{'''} یا \code{"""} گذاشت• برای ‹اینستنس› این ‹پروگرام› \argument{n}\function{f}
▼
def f(n):
	"""Function to generate Fibonacci series using recursion"""
	return n if n < 2 else f(n - 1) + f(n - 2)
▲
 یک ‹کامنت› این گونه دارد•

(در ‹پایتون› اگر با کمک \code{=} یک ‹آیدنتیفایر› برابر با ‹ولیو ـی› نشود، آنگاه آن ‹ولیو› بدون ‹فانکشنالیتی› و ‹ولیو› خواهد بود! برای ‹اینستنس› ‹کامند› 
▼
2 + 3
▲
 و ‹کامند› 
▼
"Hello"
▲
 ‹فانکشنالیتی ـی› نداشته و از آنها چشم پوشی می‌شود• پس می‌توان از ‹استرینگ ها› برای نشان دادن ‹کامنت ها› کمک گرفت: یک ‹استرینگ› به تنهایی یک ‹کامنت› هم هست! برای ‹اینستنس› 
▼
"""Function to generate Fibonacci series using recursion"""
▲
 یک ‹کامنت› است زیرا هیچ ‹فانکشنالیتی ـی› ندارد•)

\section{❬آیدنتیفایر❭}
یک ‹آیدنتیفایر› ‹نییم ـی› است برای نشان دادن یک ‹نامبر›، ‹استرینگ›، ‹لیست›، ‹کلاس› یا هر چیز دیگری• برای اینکه یک ‹آیدنتیفایر› ‹ولیو ـی› را نشان دهد باید آن را پس از \code{=} نوشت• برای ‹اینستنس› ‹کامند› \code{I = 2.71} به ‹آیدنتیفایر› \code{I} ‹ولیو› \code{2.71} را می‌دهد•

در برابر ‹لنگویج ـی› مانند ‹سی-پی-پی›، نیازی نیست پیش از ‹یوتیلایز› یک ‹آیدنتیفایر› ‹کامند ی› نوشت یا کاری کرد• همچنین یک ‹آیدنتیفایر› می‌تواند در دراز‌ای یک ‹پروگرام› ‹آدرس› هر گونه ‹دیتا ای› را داشته باشد• برای ‹اینستنس› با نوشتن ‹کامند› \code{I = 2} ‹آیدنتیفایر› \code{I} برابر با \code{2} می‌شود• (درست‌تر، ‹آدرس› \code{2} در \code{I} گذاشته می‌شود•) پس از ‹کامند› \code{I = sin} دیگر \function{I}\code{I} یک ‹نامبر› نیست! \code{I} برابر با ‹فانکشن› \code{sin} شده و می‌توان همانند یک ‹فانکشن› با آن رفتار کرد• اکنون \code{I(3.14 / 2)} ‹کامند ی› است که \code{0.9999996829318346} را ‹ریترن میکند›•

نخستین ‹کاراکتر› ‹نییم› یک ‹آیدنتیفایر› باید \code{a}، \code{b}، \ldots ، یا، \code{z} باشد• همچنین در ‹نییم› ‹آیدنتیفایر ها› نباید ‹کاراکتر› \code{@}، \code{$}، و \ldots{} باشد• ‹دولوپ› ‹پایتون› با نگرش به ‹ریدابلیتی› و زیبایی ‹پروگرام ها› بوده است• برای اینکه ‹ریدابلیتی› ‹پروگرام› بیشتر شود بهتر است ‹نییم›
\begin{description}
\item [{❬آیدنتیفایر ها❭}] با ‹کاراکتر های› کوچک نوشته شوند؛
\item [{❬کلاس ها❭}] با یک ‹کاراکتر› بزرگ آغاز گردد؛ و
\item [{❬آیدنتیفایر های❭ ❬گلوبال❭}] با ‹کاراکتر های› بزرگ نوشته شود•
\end{description}
‹نیمینگ› ‹آیدنتیفایر ها› در \ref{R13} بر ‹بیس› همین سه هنجار بوده است•

\begin{Program}
\caption{❬نیمینگ❭ ❬آیدنتیفایر ها❭ در ❬پایتون❭\label{R13}}

\function{Book}
▼
NUMBER = 10
▲
 ‹آیدنتیفایر› \code{NUMBER} یک ‹آیدنتیفایر› ‹گلوبال› است زیرا بیرون از ‹فانکشن ها› و ‹کلاس ها› نوشته شده است• ‹فانکشن ها› اگر بخواهند می‌توانند به این ‹آیدنتیفایر› ‹اکسس› داشته باشند• \local{i}
▽
class Book
	def __init__(self):
		i = NUMBER + 1
		self = i
△
 ‹کلاس› \code{Book} یک ‹کلاس› ساده است که در آن یک ‹فانکشن› نوشته شده• ‹نییم› ‹فانکشن› \code{__init__} با ‹کاراکتر› \code{_} آغاز یافته، پس دیگر ‹فانکشن ها› و ‹کلاس ها› نباید آن را ‹کال› کنند، هر چند که می‌توانند! در پایان باید گفت که ‹آیدنتیفایر› \code{i} درون یک ‹فانکشن› آمده پس باید ‹نییم› آن با ‹کاراکتر های› کوچک نوشته شود•
\end{Program}

\chapter{❬دیتا های❭ ❬فاندامنتال❭}
‹پایتون› پنج گونه ‹دیتا› ‹فاندامنتال›
\begin{itemize}
\item ‹نامبر›،
\item ‹سیکونس› ‹دیتا ها›،
\item مجموعه یا ‹ست›،
\item ‹استرینگ›، و
\item ‹دیکشنری›
\end{itemize}
را دارد که می‌توانند ‹بیس› ‹دولوپ› ‹دیتا› ‹استراکچر های› ‹کامپلکس› شوند• در اینجا کمی با هر کدام از آنها کمی آشنا می‌شویم و در \ref{=000628=00062E=000634: =000639=00062F=00062F=000647=000627} به ‹نامبر ها›، در \ref{=000628=00062E=000634: =000632=000646=00062C=0006CC=000631=000647 =00062F=000627=00062F=000647=00200C=000647=000627} به ‹سیکونس› ‹دیتا ها›، در \ref{=000628=00062E=000634: =000645=00062C=000645=000648=000639=000647=00200C=000647=000627} به ‹ست ها›، در \ref{=000628=00062E=000634: =000631=000634=00062A=000647=00200C=000647=000627} به ‹استرینگ ها›، و در \ref{=000628=00062E=000634: =000641=000631=000647=000646=0006AF=00200C=000647=000627} به ‹دیکشنری ها› خواهیم پرداخت•

\section{❬نامبر ها❭}
‹پایتون› از ‹نامبر های›
\begin{description}
\item [{❬اینتیجر❭}] مانند \code{5}،
\item [{❬دسیمال❭ یا اعشاری}] مانند \code{2.71}، و
\item [{❬عدد کامپلکس❭}] مانند \operator{j}\code{3+4j}•
\end{description}
‹ساپورت› می‌کند•

\section{❬سیکونس❭ ❬دیتا❭}
در ‹پایتون›
\begin{quotation}
چند ‹دیتا› ‹کانسکیوتیو› یک ‹سیکونس› از ‹دیتا ها›را ‹دولوپ میکنند›•
\end{quotation}
برای ‹اینستنس› \code{2, 5, 4} یک ‹سیکونس› از ‹دیتا ها› با سه ‹انتری› است•

\subsection{❬لیست❭}
یک ‹لیست› هم ‹سیکونس ای› از ‹دیتا ها› است• ‹انتری های› یک ‹لیست› که می‌توانند هر چیزی باشند را باید درون \code{[]} گذاشت• ‹لیست ها› تا اندازه‌ای مانند ‹ارری های› دیگر ‹لنگویج ها› هستند؛ اما ‹انتری های› یک ‹لیست› در ‹پایتون› می‌تواند هر چیزی از هر گونه‌ای باشد! برای ‹اینستنس› \code{[2, "a", 3.14, print]} یک ‹لیست› با چهار ‹انتری› است•

\subsection{❬تاپل ها❭}
همانند یک ‹لیست›، یک ‹تاپل› هم ‹سیکونس ای› از ‹دیتا ها› است• اما، ‹انتری های› یک ‹تاپل› باید درون \code{()} باشند و نه \code{[]}• در ‹پایتون›
\begin{quotation}
اندازه و ‹انتری های› یک ‹تاپل› را نمی‌توان تغییر داد! ‹تاپل ها› ‹لیست هایی› ‹ریدآنلی› هستند•
\end{quotation}
‹انتری های› یک ‹لیست› را به سادگی می‌توان دگرگون کرد یا از میان برداشت! اما نمی‌توان هیچ کاری روی یک ‹تاپل› کرد، مگر ‹اکسس› به ‹پارت هایی› از آن•

\section{مجموعه یا ❬ست❭}
یک مجموعه یا ‹ست› ‹لیست ـی› بدون ‹اوردر› از ‹دیتا های› ‹یونیک› می‌باشد• ‹دیتا های› درون یک ‹ست› ‹اندیس› و ‹اوردر ـی› ندارند• برای ‹دولوپ› یک ‹ست› باید ‹انتری های› آن را درون \code{\{\}} نوشت• برای ‹اینستنس› \code{\{3, 5, 2\}} یک ‹ست› با سه ‹انتری› است•

در برابر ‹لیست› و ‹تاپل›، ‹ست ها› یک برتری بسیار بزرگ دارند:
\begin{quotation}
یک ‹ست› هر اندازه‌ای هم که داشته باشد، ‹سرچ› ‹انتری ها› در آن ‹ایمدیت› خواهد بود!
\end{quotation}

\section{❬استرینگ ها❭}
به سادگی، یک ‹استرینگ› چند ‹کاراکتر› ‹کانسکیوتیو› است• برای نشان دادن ‹استرینگ ها› در ‹پایتون› باید آنها را درون \code{'}، \code{"}، \code{'''}، یا \code{"""} نوشت• ‹استرینگ های› بسیار بلند و چند ‹روو ی› را هم باید در میان \code{'''} یا \code{"""} گذاشت• برای ‹اینستنس› 
▼
"""
This program identifies the ideal customer;
	Input: Details of all customers;
	Output: ID of a customer
"""
▲
 یک ‹استرینگ› در ‹پایتون› است•

\section{❬دیکشنری ها❭}
یک ‹دیکشنری› یا ‹مپ› ‹لیست ـی› از ‹کیی های› ‹یونیک› و ‹ولیو ها› است• برای ‹دولوپ› یک ‹دیکشنری› باید ‹انتری های› آن را درون \code{\{\}} گذاشت• در یک ‹دیکشنری› ‹کیی› با \code{:} از ‹ولیو› برابر با آن جدا شده و میان ‹انتری ها› هم \code{,} گذاشته می‌شود• برای ‹اینستنس› 
▼
{
	"Name": "«جانا»",
	"Age": 18,
	"Scores": [14.0, 18.5, 9.0]
}
▲
 یک ‹دیکشنری› با سه ‹انتری› است• ‹کیی› یکی از ‹انتری ها› \likestring{Name} و ‹ولیو› برابر با آن \likestring{جانا} است• همچنین ‹کیی› یک ‹انتری› دیگر \likestring{Scores} و ‹ولیو› برابر با آن ‹لیست› کوچک \code{[14.0, 18.5, 9.0]} می‌باشد•

(اگر چه ما ‹ورد› «‹دیکشنری›» را به کار می‌بریم اما بسیاری از ‹پروگرامر ها› به آن \worddescription{دیکشنری} می‌گویند• ‹دیکشنری› ‹ایکوال› با \worddescription{مپ} در ‹سی-پی-پی› و ‹جاوا› ‹پروگرام› است•)

\section{تبدیل انواع\label{R14}}
برای تبدیل نوع یک ‹دیتا›، می‌توان از ‹فانکشن های› \ref{R15} کمک گرفت• از میان ‹فانکشن های› ‹لیست› شده، ‹فانکشن های› \code{float}، \code{int}، \code{str} و ‹یوزیج› بیشتری دارند•

\begin{Table}
\caption{❬فانکشن هایی❭ برای تبدیل انواع\label{R15}}

\begin{tabular}{5۵}
\RLE{‹فانکشن›} & آنچه ‹ریترن میشود›\\
\code{dict(s)} & ‹دیکشنری› برابر با \code{s}\\
\code{float(x)} & برابر ‹دسیمال› \code{x}\EndNote{برای ‹اینستنس› \code{float("2.71")} برابر است با \code{2.71}•}\\
\code{int(x[, base])} & ‹اینتیجر› برابر با \code{x}\EndNote{\code{base} ‹بیس ای› است که \code{x} در آن نوشته شده• برای ‹اینستنس› \code{int("101", 2)} برابر است با \code{5}• اگر \code{base} نوشته نشود به جای آن \code{10} گذاشته می‌شود•}\\
\code{list(s)} & ‹لیست› برابر با \code{s}\\
\code{repr(x)} & ‹ریپرزنتیشن›\EndNote{\wordnote{ریپرزنتیشن} برای ‹اینستنس› ‹ریپرزنتیشن› \operator{j}\code{2+3j} باید \code{2} و \code{3} را در خود داشته باشد•} \code{x}\\
\code{set(s)} & ‹ست› برابر با \code{s}\\
\code{str(x)} & ‹استرینگ› ‹دولوپ شده› از روی \code{x}\EndNote{برای ‹اینستنس› \code{str(2.71)} برابر است با ‹استرینگ› \code{"2.71"}•}\\
\code{tuple(s)} & ‹تاپل› برابر با \code{s}\\
\end{tabular}
\end{Table}

\chapter{❬اوپراتور ها❭}
‹پایتون› هم همانند دیگر ‹لنگویج های› ‹پروگرامینگ› چندین ‹اوپراتور› برای ‹پروسس› ‹دیتا ها› دارد که در اینجا به آنها می‌پردازیم•

\section{❬اوپراتور هایی❭ برای ❬اگزکیوت❭ ❬کامپیوتیشن❭}
برای ‹اگزکیوت› یک ‹کامپیوتیشن› می‌توان از آنچه در \ref{R16} آمده است کمک گرفت• ‹پایتون› در ‹اگزکیوت› ‹پروسس ها› یا ‹کامپیوتیشن ها› کمی کند‌تر از دیگر ‹لنگویج های› ‹پروگرامینگ› است• به ویژه اگر یک ‹پروگرام› پر از ‹پروسس› باشد، آنگاه این کند بودن بیشتر به چشم می‌آید• خوشبختانه ‹پکیج هایی› مانند \code{numpy} یا \code{pandas} می‌توانند ‹پروسس های› سنگین را به تندی ‹لنگویج ـی› مانند ‹سی-پی-پی› ‹اگزکیوت کنند›• (برای بدست آوردن ‹نالج› بیشتر درباره ‹پکیج ها› می‌توانید \ref{=000628=00062E=000634: =000628=000633=00062A=000647=00200C=000647=000627} را بخوانید)

\begin{Table}
\caption{❬اوپراتور های❭ ❬کامپیوتیشن ای❭\label{R16}}

\begin{tabular}{5۵}
\RLE{‹اوپراتور›} & آنچه ‹ریترن میشود›\\
\code{x + y} & $\mathtt{x}+\mathtt{y}$\\
\code{x - y} & $\mathtt{x}-\mathtt{y}$\\
\code{x * y} & $\mathtt{x}\times\mathtt{y}$\\
\code{x / y} & $\frac{\mathtt{x}}{\mathtt{y}}$\\
\code{x \% y} & $\mathtt{x}\bmod\mathtt{y}$\\
\code{x ** y} & $\mathtt{x}^{\mathtt{y}}$\\
\code{x // y} & $\left\lfloor \frac{\mathtt{x}}{\mathtt{y}}\right\rfloor $\\
\end{tabular}
\end{Table}

\section{❬اوپراتور هایی❭ برای ❬ولیو❭ دهی\label{R17}}
با ‹اوپراتور› \code{=} می‌توان یک ‹آیدنتیفایر› ‹دولوپ کرد›• پس از آن با کمک ‹اوپراتور هایی› که در \ref{R18} آمده‌اند می‌توان ‹ولیو ـی› تازه به آن ‹آیدنتیفایر› داد•

از میان ‹اوپراتور های› ‹لیست› شده در \ref{R18}، دو ‹اوپراتور› \code{+=} و \code{-=} ‹یوزیج› بیشتری دارند؛ زیرا در یک ‹پروگرام› ‹کامند هایی› مانند \code{i += 1} یا \code{i -= 1} بسیار به چشم می‌خورد•

\begin{Table}
\caption{❬اوپراتور های❭ برای ❬ولیو❭ دهی\label{R18}}

\begin{tabular}{1۹}
\RLE{‹اوپراتور›} & ‹فانکشنالیتی›\EndNote{\operator{@}برای هر ‹اوپراتور ی› مانند \code{@}، ‹کامند› \code{i @= j} کوتاه و ‹اپتیمایز› شده ‹کامند› \code{i = i @ j} است• همچنین باید دانست که ‹کامند› \code{i = i @ j} کمی کندتر از ‹کامند› \code{i @= j} کار می‌کند•}\\
\code{i += j} & افزودن \code{j} به \code{i}\\
\code{i -= j} & کاستن \code{j} از \code{i}\\
\code{i *= j} & \code{j} برابر کردن \code{i}\\
\code{i /= j} & \code{i} را بر \code{j} ‹پارت› می‌کند\\
\code{i \%= j} & مانده ‹پارت› کردن \code{i} بر \code{j} را درون \code{i} می‌گذارد\\
\code{i **= j} & \code{i} را به توان \code{j} می‌رساند\\
\code{i //= j} & ‹پارت› کردن \code{i} بر \code{j} با چشم پوشی از ‹پارت› اعشاری\\
\end{tabular}
\end{Table}

در ‹پایتون› \code{=} چند تایی هم شدنی است• برای ‹اینستنس› \code{x = y = 1} به هر دو ‹آیدنتیفایر› \code{x} و \code{y} ‹ولیو› \code{1} می‌دهد• این ‹کامند› کوتاه شده دو ‹کامند› \code{y = 1} و \code{x = y} است•

‹کامند› \code{a, b = 3, 5} هم در ‹پایتون› درست است و تا اندازه‌ای برابر با دو ‹کامند› \code{a = 3} و \code{b = 5} می‌باشد• درست‌تر، در این ‹کامند› یک ‹تاپل› با ‹انتری های› \code{3} و \code{5} ‹دولوپ میشود›؛ سپس \code{a} و \code{b} برابر ‹انتری های› این ‹تاپل› می‌شوند• برای همین در ‹پایتون› ‹کامند ی› مانند \code{b, a = a, b} را می‌توان نوشت! این ‹کامند› ‹ولیو› درون ‹آیدنتیفایر های› \code{a} و \code{b} را با هم ‹ریپلیس› می‌کند• پس این ‹کامند› ‹ایکوال› با ‹کامند های› \code{x = a}، \code{y = b}، \code{b = x}، و \code{a = y} می‌باشد•

\section{❬اوپراتور های❭ مقایسه‌ای}
این ‹اوپراتور ها› که در \ref{R19} آمده‌اند برای سنجیدن ‹ولیو ها› در برابر یک دیگر هستند• برای ‹اینستنس› ‹استاتمنت› \code{2 + 2 == 4} ‹ترو› است•
\begin{quotation}
در ‹پایتون› «‹ترو›» را با \code{True} و «‹فالس›» را با \code{False} نشان می‌دهند•
\end{quotation}
در \ref{R23} خواهیم دید که ‹کامند› \code{if} تنها اگر یک ‹استاتمنت› یا ‹کاندیشن› ‹ترو› باشد ‹کامند هایی› را ‹اگزکیوت میکند›•

\begin{Table}
\caption{❬اوپراتور های❭ مقایسه‌ای\label{R19}}

\begin{tabular}{1۹}
\RLE{‹اوپراتور›} & زمانی ‹ترو› است که \ldots\\
\code{a == b} & \code{a} برابر \code{b} باشد•\\
\code{a != b} & \code{a} برابر \code{b} نباشد•\\
\code{a < b} & \code{a} کوچک‌تر از \code{b} باشد•\\
\code{a > b} & \code{a} بزرگ‌تر از \code{b} باشد•\\
\code{a <= b} & \code{a} کوچک‌تر یا برابر \code{b} باشد•\\
\code{a >= b} & \code{a} بزرگ‌تر یا برابر \code{b} باشد•\\
\end{tabular}
\end{Table}

\section{❬اوپراتور های❭ ❬لاجیک ـی❭}
‹پایتون› همانند هر ‹لنگویج› ‹پروگرامینگ› دیگری سه ‹اوپراتور› آورده شده در \ref{R20} را دارد•

هنگام ‹ایولویشن› هر ‹استراکچر ی› که ‹امپتی› باشد ‹ایکوال› با \code{False} خواهد بود! برای ‹اینستنس› ‹لیست› ‹امپتی›، \code{[]}، ‹ایکوال› با ‹فالس› است• همچنین ‹استرینگ› ‹امپتی›، \code{""}، نیز ‹ایکوال› با ‹فالس› است• برای همین \code{[2] and \{\}} ‹ایکوال› با \code{True and False} و برابر با \code{False} می‌شود•

همان گونه که در \ref{R20} آمده است، \code{p or q}، اگر \code{p} ‹ترو› باشد، آنگاه \code{p} را ‹ریترن میکند› و اگر اینگونه نباشد، آنگاه \code{q} است که ‹ریترن میشود›• برای همین است که \code{[] or [2, 3]} برابر با \code{[2, 3]} می‌شود! زیرا \code{[]} یک ‹لیست› ‹امپتی› و ‹ایکوال› با \code{False} است، پس ‹ریسپانس› \code{[2, 3]} خواهد بود• همچنین اگر پیش از ‹کامند› 
▼
NAME = NAME or "«بی‌نام»"
▲
 ‹آیدنتیفایر› \code{NAME} ‹امپتی› بوده باشد، آنگاه پس از این ‹کامند› برابر \likestring{بی‌نام} می‌شود؛ اما اگر ‹امپتی› نبوده باشد، چیزی رخ نمی‌دهد! این ‹متد› ‹یوتیلایز› \code{or} ‹پروگرام› را کوتاه‌تر می‌کند زیرا ‹فانکشنالیتی ی› مانند ‹کامند› \code{if} که در \ref{R29} آمده است را دارد•

\begin{Table}
\caption{❬اوپراتور های❭ ❬لاجیک ـی❭\label{R20}}

\begin{tabular}{2۸}
\RLE{‹اوپراتور›} & ‹فانکشنالیتی›\\
\code{p and q} & باید هر دو ‹استاتمنت› \code{p} و \code{q} ‹ترو› باشند تا ‹ریسپانس› ‹ترو› گردد\EndNote{اگر \code{p} ‹فالس› باشد، آنگاه ‹ترو› یا ‹فالس› بودن \code{q} بررسی هم نمی‌شود!}•\\
\code{p or q} & باید دست کم یکی از دو ‹استاتمنت› \code{p} و \code{q} ‹ترو› باشد تا ‹ریسپانس› ‹ترو› شود\EndNote{اگر \code{p} ‹فالس› نباشد، آنگاه \code{p} ‹ریترن میشود›؛ اگر نه، \code{q} ‹ریسپانس› خواهد بود•}•\\
\code{not p} & ‹استاتمنت› \code{p} را ‹اینورت› می‌کند•\\
\end{tabular}
\end{Table}

\section{\operator{in}❬اوپراتور های❭ \code{in} و \code{not in}}
\operator{in}دو ‹اوپراتور› آورده شده در \ref{R21} بودن یا نبودن یک ‹دیتا› در میان یک ‹سیکونس› از ‹دیتا ها› را بررسی می‌کنند• این دو می‌توانند در هر ‹سیکونس ای› از ‹دیتا ها› آنچه ‹ریکوست› شده را بیابد• ‹سیکونس› می‌تواند ‹لیست›، ‹تاپل›، ‹دیکشنری›، ‹ست›، ‹استرینگ› یا \ldots{} باشد• \ref{R22} ‹متد› یافتن ‹ساب-استرینگ ای› دلخواه را نشان می‌دهد•

\begin{Table}
\caption{\operator{in}❬اوپراتور های❭ \code{in} و \code{not in}\label{R21}}

\begin{tabular}{4۶}
\RLE{‹اوپراتور›} & ‹فانکشنالیتی›\\
\code{d in e} & اگر \code{d} در میان ‹انتری های› \code{e}\EndNote{اگر \code{e} یک ‹دیکشنری› باشد، آنگاه ‹سرچ› در میان ‹کیی های› آن رخ می‌دهد و نه در میان ‹ولیو های› درون آن! چرایی این رفتار در ‹پارت› پیش رو، \ref{R23}، آمده است•} باشد ‹ریسپانس› ‹ترو› خواهد بود•\\
\code{d not in e} & ‹استاتمنت ای› ‹ترو› است اگر \code{d} در میان ‹انتری های› \code{e}\EndNoteMark{0} نباشد\EndNote{به جای \code{d not in e} می‌توان \code{not d in e} هم نوشت• اما از دید بسیاری این ‹ریپلیس ـی› ‹ریدابلیتی› ‹پروگرام› را پایین می‌آورد•}•\\
\end{tabular}
\end{Table}

\begin{Program}
\caption{یافتن یک ❬ساب-استرینگ❭\label{R22}}

\operator{in}در ‹بایولوژی› ‹سیکونس› \likestring{TATA} نشانه آغاز یک ‹جین› است• اگر 
▼
if "TATA" in "TCATTATAAAAGC":
	print("TATA Box Detected")
else:
	print("No TATA Box")
▲
 ‹کال شود›، آنگاه 
⧨
TATA Box Detected
◭
 ‹پرینت› می‌شود• زیرا در ‹استرینگ› \likestring{TCATTATAAAAGC} ‹ساب-استرینگ› \likestring{TATA} را می‌توان یافت•
\end{Program}

\section{❬اوپراتور های❭ ❬بیتوایز❭}
(درباره اینها چیزی نمی‌گوییم زیرا گفتنی‌های بهتری داریم•)

\chapter{❬کامند های❭ ❬استراکچرد❭\label{R23}}
یک ‹پروگرام› ‹استراکچرد› از ‹پارت هایی› کوچک، مانند آنهایی که \ref{R24}، \ref{R25}، و \ref{R26} آمده، ‹دولوپ شده› است• با کنار هم گذاشتن این ‹پارت ها› یا ‹استراکچر ها› می‌توان ‹پروگرام هایی› بسیار ‹کامپلکس› نیز ‹دولوپ کرد›؛ برای ‹اینستنس› \ref{R27} ‹کامپوننت ای› از یک ‹پروگرام› ‹کامپلکس› ‹استراکچرد› را نشان می‌دهد که چهار ‹پارت› کوچک دارد•

\begin{Figure}
\begin{tikzpicture}
	\matrix
	{
		|(S)[junction]|\\
		|(C1)[activity, wide]|❬کامند هایی❭ برای ❬اگزکیوت❭ یک و تنها یک کار یا ❬پروسس❭\\
		|(C2)[activity, wide]|❬کامند هایی❭ برای ❬اگزکیوت❭ یک کار یا یک ❬پروسس❭ دیگر\\
		|(E)[junction]|\\
	}; 
	{[edges]
		\draw (S) -- (C1);
		\draw (C1) -- (C2);
		\draw (C2) -- (E);
	}
\end{tikzpicture}

\caption{در یک ❬پروگرام❭ ❬استراکچرد❭ چند ❬کامند❭ که یک و تنها یک ❬پارت❭ از ❬پروسه❭ را ❬ایمپلیمنت❭ می‌کنند می‌توانند پس از چند ❬کامند❭ که ❬پارت❭ دیگری را ❬ایمپلیمنت❭ می‌کنند بی‌آیند\label{R24}}
\end{Figure}

\begin{Figure}
\begin{tikzpicture}
	\matrix
	{
		&|(S)[junction]|\\
		|(Y)[activity]|تنها اگر ❬استاتمنت❭ ❬ترو❭ باشد این ❬کامند ها❭ ❬اگزکیوت میشوند❭&|(D)[decision]|❬استاتمنت❭&|(N)[activity]|این ❬کامند ها❭ زمانی که ❬استاتمنت❭ ❬فالس❭ باشد ❬اگزکیوت میشوند❭\\
		&|(E)[junction]|\\
	}; 
	{[edges]
		\draw (S) -- (D);
		\draw (D) -- node {❬ترو❭} (Y);
		\draw (D) -- node {❬فالس❭} (N);
		\draw (Y) |- (E);
		\draw (N) |- (E);
	}
\end{tikzpicture}

\caption{برخی از ❬پارت های❭ ❬دولوپ کننده❭ یک ❬پروگرام❭ ❬استراکچرد❭ تنها زمانی که یک ❬استاتمنت❭ ❬ترو❭ یا ❬فالس❭ باشد ❬کال میشوند❭\label{R25}}
\end{Figure}

\begin{Figure}
\begin{tikzpicture}
	\matrix
	{
		|(S)[junction]|\\
		|(D)[decision]|❬استاتمنت❭&|(E)[junction]|\\
		|(A)[activity, wide]|اگر ❬استاتمنت❭ ❬ترو❭ باشد این ❬کامند ها❭ ❬اگزکیوت میشوند❭ و دوباره ❬استاتمنت❭ بررسی می‌شود\\
	}; 
	{[edges]
		\draw (S) -- (D);
		\draw (D) -- node {❬ترو❭} (A);
		\draw (D) -- node {❬فالس❭} (E);
		\draw (A.west) -- +(-1.5em, 0) |- (D.west);
	}
\end{tikzpicture}

\caption{در یک ❬پروگرام❭ ❬استراکچرد❭ می‌توان ❬پارت ـی❭ از ❬پروگرام❭ را چندین بار ❬اگزکیوت کرد❭\label{R26}}
\end{Figure}

\begin{Figure*}
\def\activity{❬کامند هایی❭ برای ❬اگزکیوت❭ یک ❬پارت❭ از ❬پروسه❭}
\def\decision{❬استاتمنت❭}
\begin{tikzpicture}
	\matrix
	{
		&|(S)[junction]|&&&|(C10)[activity, wide]|\activity\\
		|(C1)[activity, wide]|\activity&|(D1)[decision]|\decision&&|(D4)[decision]|\decision&|(C9)[activity, wide]|\activity\\
		&|(C2)[activity, wide]|\activity&&|(C6)[activity, wide]|\activity\\
		|(C4)[activity, wide]|\activity&|(D2)[decision]|\decision&|(D3)[decision]|\decision&|(C5)[activity, wide]|\activity\\
		|(C7)[activity, wide]|\activity&&|(E)[junction]|\\
	};
	{[edges]
		\draw (S) -- (D1);
		\draw (D1) -- (C1);
		\draw (D1) -- (C2);
		\draw (C1) |- (C2);
		\draw (C2) -- (D2);
		\draw (D2) -- (D3);
		\draw (D3) -- (C5);
		\draw (C5) -- (C6);
		\draw (C6) -- (D4);
		\draw (D4) -| (D3);
		\draw (D4) -- (C9);
		\draw (C9) -- (C10);
		\draw (C10) -| (D4);
		\draw (D3) -- (E);
		\draw (D2) -- (C4);
		\draw (C4) -- (C7);
		\draw (C7) -| (D2);
	}
	{[highlights]
		\node [fit=(C2)(C2)] {};
		\node [fit=(D1)(C1)] {};
		\node [fit=(D2)(C4)(C7)] {};
		\node (F1) [fit=(D4)(C9)(C10)] {};
		\node [fit=(D3)(C5)(C6)(F1)] {};
	}
	\TikzNewNoteMark C1.north west;
	\TikzNewNoteMark C4.north west;
	\TikzLastNoteMark C7.north west;
	\TikzNewNoteMark F1.north west;
\end{tikzpicture}\EndNoteText{تنها اگر ‹استاتمنت› ‹ترو› باشد این ‹کامند ها› کار خود را ‹اگزکیوت میکنند›•}\EndNoteText{تا زمانی که ‹استاتمنت› ‹ترو› باشد این ‹پارت› از ‹پروگرام› ‹کال میشود› یا کار می‌کند•}\EndNoteText{این ‹لوپ› کوچک خود ‹پارت ـی› از یک ‹لوپ› بزرگ‌تر است•}

\caption{❬کامپوننت ای❭ از یک ❬پروگرام❭ ❬استراکچرد❭ ❬کامپلکس❭ که ❬پارت های❭ ❬دولوپ کننده❭ آن ❬هایلایت❭ شده است• می‌توان دید که ❬پارت های❭ آن همان‌هایی هستند که در \ref{R24}، \ref{R25}، و \ref{R26} آمده‌اند• در یک ❬پروگرام❭ ❬کامپلکس❭، یک ❬پارت❭ می‌تواند ❬پارت هایی❭ کوچک‌تر درون خود داشته باشد• برای ❬اینستنس❭ در اینجا یکی از ❬پارت ها❭ که ❬لوپ❭ است درون خود یک ❬لوپ❭ کوچک‌تر دارد\label{R27}}
\end{Figure*}

برای دادن ‹استراکچر› به یک ‹پروگرام›، ‹پایتون› ‹کامند های› ‹استراکچرد› \ref{R28} را دارد• که در \ref{R29}، \ref{R33}، و \ref{R36} به آنها پرداخته شده است•

\begin{Table}
\caption{❬کامند های❭ ❬استراکچرد❭\label{R28}}

\begin{tabular}{1۹}
\RLE{‹کامند›} & ‹فانکشنالیتی›\\
\code{if} & ‹اگزکیوت› ‹کامند ها› هنگام ‹ترو› بودن یک ‹استاتمنت›\\
\code{while} & ‹اگزکیوت› ‹کامند ها› تا زمانی که ‹استاتمنت ای› ‹ترو› است\\
\code{for} & ‹اگزکیوت› ‹کامند ها› روی ‹انتری های› یک ‹سیکونس›\\
\end{tabular}
\end{Table}

\section{❬کامند❭ \code{if}\label{R29}}
‹کامند› \code{if} ‹پایتون› مانند ‹کامند› \code{if} دیگر ‹لنگویج های› ‹پروگرامینگ› است:
\begin{quotation}
اگر ‹استاتمنت› نوشته شده ‹ترو› باشد ‹کامند های› درون \code{if} ‹کال میشوند›•
\end{quotation}
در همه ‹لنگویج های› ‹پروگرامینگ› باید ‹کامند› \code{if} به همراه یک ‹استاتمنت› و ‹کامند هایی› که با ‹ترو› بودن ‹استاتمنت› باید ‹اگزکیوت شوند› پشت سر هم باشند•

\begin{Usage}
برای ‹یوتیلایز› ‹کامند› \code{if} در ‹پایتون› باید \command{statements}\operator{condition}
▼
if condition:
	statements
▲
 که در آن \code{statements} ‹کامند هایی› هستند که تنها اگر \code{condition} ‹ترو› باشد ‹کال میشوند› را نوشت•
\end{Usage}

در ‹سی-پی-پی›، برای نشان دادن اینکه ‹کامند هایی› درون یک ‹کامند› دیگر هستند، باید آنها را درون \code{\{\}} نوشت• اما در ‹پایتون› باید آن ‹کامند ها› را کمی جلو‌تر نوشت• این ‹ایندنشن ها› باید در ‹انتایر› ‹پروگرام› یکسان باشند• بسیاری از ‹پروگرامر ها› با چهار \likestring{ } ‹ایندنشن› را ‹دولوپ میکنند›• برخی دیگر ‹کاراکتر› \likestring{TAB} را ‹یوتیلایز میکنند›•

همانند دیگر ‹لنگویج های› ‹پروگرامینگ›، در ‹پایتون› هم یک ‹کامند› \code{if} می‌تواند ‹پارت› \code{else} داشته باشد:
\begin{quotation}
اگر ‹استاتمنت› ‹ترو› باشد ‹کامند های› درون ‹کامند› \code{if} و اگر ‹فالس› باشد ‹کامند های› درون ‹پارت› \code{else} ‹اگزکیوت میشوند›•
\end{quotation}
‹کامند› \code{if} ‹پایتون› \ref{R25} را ‹ایمپلیمنت› می‌کند و به ‹پروگرام› ‹استراکچر ی› می‌دهد• با ‹یوتیلایز› این ‹کامند› و دو ‹کامند› \code{while} و \code{for} که کمی جلو‌تر به آنها پرداخته شده است می‌توان یک ‹پروگرام› ‹استراکچرد› با هر ‹کامپلکسیتی› را نوشت•

در \ref{R30} که ‹ایمپلیمنت› \ref{R3} است با کمک ‹کامند› \code{if} که ‹پارت› \code{else} هم دارد $\left|\mathtt{x}\right|$ بدست می‌آید• می‌توان دید که با ‹یوتیلایز› ‹کامند› \code{if} ‹پروگرام› ‹استراکچر ی› به خود گرفته است• \ref{R30} تنها سه ‹کامند› دارد که ‹هایلایت› شده‌اند:
\begin{enumerate}
\item ‹کامند ی› برای گرفتن \code{x} از ‹یوزر›؛
\item ‹کامند› \code{if} که در آن ‹کامند› \code{y = -x} و در ‹پارت› \code{else} آن هم ‹کامند› \code{y = +x} نوشته شده است؛ و
\item ‹کامند ی› برای نمایش ‹ریسپانس›، \code{y}، به ‹یوزر›•
\end{enumerate}
\begin{Program}
\caption{بدست آوردن $\left|x\right|$\label{R30}}

\begin{structure}
▼
x = float(input("«یک␣عدد␣بدهید»"))
▲
\end{structure}
\begin{structure}
▽
if x < 0:
△
\begin{structure}
▽
y = -x
△
\end{structure}
▽
else:
△
\begin{structure}
▽
y = +x
△
\end{structure}
\end{structure}
\begin{structure}
▽
print(y)
△
\end{structure}
در این ‹پروگرام› ‹کامند› \code{y = -x} درون ‹کامند› \code{if} است؛ زیرا کمی جلو‌تر از آن نوشته شده• ‹کامند› \code{y = -x} هم درون ‹پارت› \code{else} آن ‹کامند› \code{if} است•
\end{Program}

درون یک ‹کامند› \code{if} می‌توان هر ‹کامند ی› نوشت• پس در یک ‹پروگرام› می‌توان ‹کامند های› \code{if} ‹نستد› هم داشت• برای ‹اینستنس› در \ref{R31} ‹ماکسیمم› \code{A}، \code{B}، و \code{C} با دو ‹کامند› \code{if} ‹نستد› بدست می‌آید• اگر چه نوشتن ‹کامند های› \code{if} ‹نستد› شدنی است، اما ‹سجست› نمی‌شود زیرا هم نوشتن و هم ‹رید› ‹پروگرام› را سخت می‌کند•

\begin{Program}
\caption{یافتن ❬ماکسیمم❭ \code{A}، \code{B}، و \code{C}\label{R31}}

▼
A = int(input("A:"))
B = int(input("B:"))
C = int(input("C:"))
▲
 \code{A}، \code{B}، و \code{C} از ‹یوزر› گرفته می‌شوند• 
▽
if A > B:
△
 اگر \code{A > B} باشد، 
▽
	if A > C:
△
 و \code{A > C} هم باشد، 
▽
		print(A)
△
 آنگاه \code{A} هم از \code{B} و هم از \code{C} بزرگ‌تر است و ‹پرینت› می‌شود• 
▽
	else:
△
 اما اگر \code{A > C} نباشد، 
▽
		print(C)
△
 آنگاه باید \code{C} ‹ماکسیمم› باشد• پس \code{C} ‹پرینت› می‌شود• 
▽
else:
△
 اگر \code{A > B} نباشد، 
▽
	if B > C:
△
 و \code{B > C} باشد، 
▽
		print(B)
△
 آنگاه \code{B} که باید بزرگ‌ترین باشد ‹پرینت› می‌شود 
▽
	else:
△
 اگر \code{B} هم مانند \code{A} بزرگ‌تر از \code{C} نباشد، بی‌گمان \code{C} ‹ماکسیمم› است و 
▽
	else:
		print(C)
△
 ‹پرینت› می‌شود•
\end{Program}

در ‹پارت› \code{else} ‹کامند› \code{if} \ref{R31} یک \code{if} دیگر ‹یوتیلایز شده›• به این ‹استراکچر› \code{else if} می‌گویند• در ‹پایتون› \code{else if} را می‌توان به سادگی \code{elif} نوشت•

\begin{Usage}
برای ‹یوتیلایز› ‹استراکچر› \code{elif}\EndNote{‹کامند› \code{match} که به ‹پایتون› \code{3.10} افزوده شده ‹ایکوال› با این ‹استراکچر› است اما ‹ریدابلیتی› بیشتری از این ‹استراکچر› دارد و ‹یوتیلایز› آن به جای این ‹استراکچر› ‹سجست› می‌شود•}\EndNote{این ‹استراکچر› کم و بیش ‹ایکوال› با ‹کامند› \command{switch}\code{switch} ‹لنگویج هایی› مانند ‹سی-پی-پی› و ‹جاوا› است•} در ‹پایتون› باید \command{other_statements, statements_1, statements_2, statements_n, statements_i}\operator{condition_1, condition_2, condition_n, condition_i}
▼
if condition_1:
	statements_1
elif condition_2:
	statements_2
...
elif condition_n:
	statements_n
else
	other_statements
▲
 را نوشت؛ که در آن \code{statements_i} ‹کامند هایی› هستند که اگر \code{condition_i} ‹ترو› باشد ‹اگزکیوت میشوند› و \code{other_statements} هم ‹کامند هایی› هستند که اگر هیچ کدام ‹ترو› نباشند ‹کال میشوند›• همانند خودِ ‹کامند› \code{if} در اینجا هم می‌توان ‹پارت› \code{else} را ننوشت•
\end{Usage}

در \ref{R32} که ‹ایمپلیمنت› \ref{R4} است این ‹استراکچر› ‹یوتیلایز شده›•

\begin{Program}
\caption{یافتن برابر ❬استرینگ ای❭ یک ❬دیجیت❭\label{R32}}

▼
D = int(input("«یک␣رقم␣بدهید»"))
▲
 ‹آیدنتیفایر› \code{D} از ‹یوزر› گرفته می‌شود؛ و 
▽
if D == 0:
	print("«صفر»")
△
 اگر \code{0} باشد، \likestring{صفر} ‹پرینت› می‌شود؛ و 
▽
elif D == 1:
	print("«یک»")
△
 اگر \code{0} نباشد و \code{1} باشد، \likestring{یک} ‹پرینت› می‌شود؛ و 
▽
elif D == 2:
	print("«دو»")
△
 اگر \code{0} و \code{1} نباشد و \code{2} باشد، \likestring{دو} ‹پرینت› می‌شود؛ و 
▽
elif D == 3:
	print("«سه»")
△
 اگر \code{0}، \code{1}، و \code{2} نباشد و \code{3} باشد، \likestring{سه} ‹پرینت› می‌شود و \ldots{} 
▽
elif D == 4:
	print("«چهار»")
elif D == 5:
	print("«پنج»")
elif D == 6:
	print("«شش»")
elif D == 7:
	print("«هفت»")
elif D == 8:
	print("«هشت»")
elif D == 9:
	print("«نه»")
else:
	print("«شما␣یک␣رقم␣ندادید!»")
△
 در پایان اگر هیچ کدام نباشد \likestring{شما یک رقم ندادید!} ‹پرینت› می‌شود•
\end{Program}

\section{❬کامند❭ \code{while}\label{R33}}
برای ‹اگزکیوت› ‹کامند ها› تا زمانی که یک ‹کاندیشن› ‹ترو› است ‹کامند› \code{while} به کار می‌رود• این ‹کامند› ‹پایتون› هم \ref{R26} را ‹ایمپلیمنت› می‌کند؛ پس ‹یوتیلایز› ‹کامند› \code{while} نیز به ‹پروگرام› ‹استراکچر ی› می‌دهد•

\begin{Usage}
برای ‹یوتیلایز› ‹کامند› \code{while} در ‹پایتون› باید \command{statements}\operator{condition}
▼
while condition:
	statements
▲
 که در آن \code{condition} ‹استاتمنت› یا ‹کاندیشن› و \code{statements} هم ‹کامند ها› هستند را نوشت•
\end{Usage}

زمانی که باید یک کار را چندین بار ‹اگزکیوت کرد› به ‹کامند› \code{while} نیاز است• برای ‹اینستنس› نشان دادن $2^{i}$ برای $0\leq i\leq3$ ‹پروسه ی› است که در آن باید نشان دادن $2^{i}$ را چندین بار ‹اگزکیوت کرد›• ‹فلوچارت ی› این ‹پروسه› و ‹پروگرام› آن به ‹پایتون› در \ref{R34} و \ref{R35} آمده است• \ref{R35} تنها دو ‹کامند› دارد:
\begin{enumerate}
\item ‹کامند ی› برای ‹دولوپ› ‹کانتر› \code{I} و
\item ‹کامند› \code{while} که درون آن دو ‹کامند› دیگر برای نمایش $2^{\mathtt{I}}$ و افزودن به \code{I} هست•
\end{enumerate}
‹پارت های› ‹ایکوال› با این دو ‹کامند› در \ref{R34} هم ‹هایلایت› شده‌اند•

\begin{Flowchart}
\begin{tikzpicture}
	\matrix
	{
		|(S)[terminator]|Start&|(C1)[computation]|$i\gets0$\\
		|(O)[output]|$i,i^2$&|(D)[decision]|$i\le3$&|(E)[terminator]|End\\
		|(C2)[computation]|$i\gets i+1$\\
	};
	{[edges]
		\draw (S) -- (C1);
		\draw (C1) -- (D);
		\draw (D) -- node {خیر} (E);
		\draw (D) -- node {بله} (O);
		\draw (O) -- (C2);
		\draw (C2) -| (D);
	}
	{[highlights]
		\node [fit=(C1)(C1)] {};
		\node (F) [fit=(D)(O)(C2)] {};
	}
	\TikzNewNoteMark F.north east;
\end{tikzpicture}\EndNoteText{این ❬سایکل❭ با کمک ❬کامند❭ \code{while} ❬ایمپلیمنت❭ می‌شود•}\caption{❬پرینت❭ کردن توان‌های \code{2}\label{R34}}
\end{Flowchart}

\begin{Program}
\caption{❬پرینت❭ کردن توان‌های \code{2}\label{R35}}

\begin{structure}
▼
I = 0
▲
 ‹کانتر›\EndNote{یک ‹کانتر› نشان می‌دهد که برای بار چند‌م است که ‹کامند ها› ‹اگزکیوت میشوند› و می‌تواند ‹ولیو› دیگری هم نداشته باشد•} \code{I} برابر با \code{0} می‌شود•%
\end{structure}
\begin{structure}
▽
while I <= 3:
△
 تا زمانی که \code{I <= 3} است، %
\begin{structure}
▽
print(I, 2**I)
△
 \code{I} و $\mathtt{2}^{\mathtt{I}}$ ‹پرینت› شده و%
\end{structure}
\begin{structure}
▽
I += 1
△
 یکی به \code{I} افزوده می‌شود•%
\end{structure}
\end{structure}

‹ریسپانس› این ‹پروگرام› 
⧨
0 1
1 2
2 4
3 8
◭
 خواهد بود•
\end{Program}

\section{❬کامند❭ \code{for}\label{R36}}
با کمک این ‹کامند› نیز می‌توان کار‌هایی را برای چندین بار ‹اگزکیوت کرد›• پس ‹کامند› \code{for} ‹پایتون› هم \ref{R26} را ‹ایمپلیمنت› می‌کند و ‹یوتیلایز› آن ‹استراکچر ی› به ‹پروگرام› می‌دهد•

‹کامند› \code{for} روی تک تک ‹دیتا هایی› که در یک ‹دیتا› ‹استراکچر› آمده‌اند کاری را ‹اگزکیوت میکند›• برای ‹اینستنس› این ‹کامند› می‌تواند ‹پروسس ـی› را روی ‹انتری های› یک ‹لیست› ‹اگزکیوت کند›•

\command{statements}
\begin{Usage}
برای ‹یوتیلایز› ‹کامند› \code{for} در ‹پایتون› باید 
▼
for identifier in iterable:
	statements
▲
 که در آن \code{identifier} ‹آیدنتیفایر ای› است که هر بار برابر با یکی از ‹انتری های› \code{iterable}\EndNote{\code{iterable} می‌تواند هر ‹دیتا› ‹استراکچر› یا ‹کلاس ای› که ‹فانکشن› \code{__iter__()} یا ‹فانکشن› \code{__next__()} را ‹ایمپلیمنت› کرده است باشد• خوشبختانه، ‹دولوپر ها› ‹پایتون› این کار را برای ‹لیست›، ‹تاپل›، ‹ست›، ‹استرینگ›، و ‹دیکشنری› ‹اگزکیوت کردن›؛ پس می‌توان با کمک ‹کامند› \code{for} از روی این ‹دیتا› ‹استراکچر ها› ‹پسس› کرد• نگران نباشید، در \ref{=000628=00062E=000634: =000631=00062F=000647=00200C=000647=000627} به ‹متد› ‹ایمپلیمنت› اینها آنگونه که بایسته است پرداخته‌ایم•} می‌شود و \code{statements} هم ‹کامند ها› هستند را نوشت•

به سادگی، با ‹کامند› \code{for} می‌توان از روی یک ‹دیتا› ‹استراکچر› ‹پسس›\EndNote{هنگام ‹پسس› از روی یک ‹دیتا› ‹استراکچر› هر کدام از ‹پارت های› ‹دولوپ کننده› آن یک و تنها یک بار دیده می‌شوند•} کرد• هنگام ‹پسس› از روی هر ‹انتری› ‹آیدنتیفایر› نوشته شده برابر با آن ‹انتری› می‌شود•
\end{Usage}

‹کامند› \code{for} هر بار به ‹آیدنتیفایر› \code{identifier} یکی از ‹دیتا های› آمده در ‹دیتا› ‹استراکچر› \code{iterable} که می‌تواند ‹لیست›، ‹تاپل›، ‹ست›، ‹استرینگ›، ‹دیکشنری›، یا هر ‹سریز› دیگری از ‹دیتا ها› باشد را می‌دهد و پس از آن \code{statements} که چند ‹کامند› هستند را ‹اگزکیوت›• برای ‹اینستنس› \ref{R37} را ببینید•

\begin{Program}
\caption{بدست آوردن ❬اوریج❭ یک ❬استیودنت❭\label{R37}}

▼
L = [14, 13, 18.25]
N = 0
S = 0
for K in L:
▲
 ‹آیدنتیفایر› \code{K} هر بار یکی از ‹انتری های› ‹لیست› \code{L} می‌شود• بار نخست، ‹آیدنتیفایر› \code{K} برابر \code{14} شده و ‹کامند های› درون ‹کامند› \code{for} ‹کال میشوند›• پس از آن، در بار دوم، ‹آیدنتیفایر› \code{K} برابر با \code{13} شده و دو‌باره همان ‹کامند های› درونی ‹کال میشوند›• در بار سوم و پایانی، \code{K} برابر با \code{18.25} شده و ‹کامند های› درون ‹کامند› \code{for} ‹اگزکیوت میشوند›• 
▽
	S += K
	N += 1
△
 این دو ‹کامند› درون ‹کامند› \code{for} هستند؛ زیرا کمی جلو‌تر از آن نوشته شده‌اند• ‹کامند› \code{S += K} همان ‹آیدنتیفایر› \code{K} را به \code{S} و ‹کامند› \code{N += 1} هم یکی به ‹کانتر› \code{N} می‌افزاید• 
▽
print("«❬اوریج❭␣شما»", S / N, "«است.»")
△

‹ریسپانس› این ‹پروگرام› 
⧩
«است.» 15.083333333333334«\NewNoteMark» «میانگین شما»
◮
 خواهد بود•\EndNoteText{در \ref{=000628=000631=000646=000627=000645=000647: =00067E=000631 =0006A9=000631=00062F=000646 =000628=00062E=000634=0006CC =000627=000632 =0006CC=0006A9 =000631=000634=00062A=000647} \ref{=000628=00062E=000634: =000631=000634=00062A=000647=00200C=000647=000627} ‹متد ـی› برای ‹پرینت› زیبا‌تر ‹اوریج› آمده است•}
\end{Program}

\section{❬کامند هایی❭ برای شکستن و از سر گیری ❬لوپ ها❭}
برای بیرون رفتن زود هنگام از یک ‹لوپ› و از سر گیری آن ‹پایتون› ‹کامند های› \code{break} و \code{continue} را دارد•

\subsection{❬کامند❭ \code{break}}
گاهی باید با پیش آمدن یک ‹ایونت› از ‹لوپ› کنونی بیرون رفت• همان گونه که \ref{R38} نشان می‌دهد، ‹کامند› \code{break} یک ‹لوپ› را شکانده و نخستین ‹کامند› پس از آن ‹کال میشود›• این ‹کامند›، پس از ‹ترو› شدن یک ‹استاتمنت›، ‹سایکل› ‹اگزکیوت› ‹کامند ها› را زود‌تر از آنچه باید به پایان می‌رساند• ‹متد› ‹یوتیلایز› این ‹کامند› در \ref{R39} آورده شده است•

\begin{Figure}
\begin{tikzpicture}
	\matrix
	{
		&|(S)[junction]|\\
		&|(D)[decision]|❬استاتمنت❭ ۱&|(E)[junction]|\\
		&|(A)[activity]|❬کامند ها❭&|(B)[activity, color=red]|❬کامند❭ \code{break}\\
		|(N)[activity]|❬کامند ها❭&|(C)[decision]|❬استاتمنت❭ ۲&|(P)[activity, color=red]|❬کامند ها❭\\
	};
	{[edges]
		\draw (S) -- (D);
		\draw (A) -- (C);
		\draw (D) -- node {❬ترو❭} (A);
		\draw (D) -- node {❬فالس❭} (E);
		\draw[red] (C) -- node {❬ترو❭} (P);
		\draw (C) -- node {❬فالس❭} (N);
		\draw (N) |- (D);
		\draw[red] (P) -- (B);
		\draw[red] (B) -- (E);
	}
	{[highlights]
		\node (F) [fit=(D)(A)(N)(C)] {};
	}
	\TikzNewNoteMark F.north west;
	\TikzNewNoteMark P.north west;
	\TikzNewNoteMark C.north;
	\TikzNewNoteMark N.north west;
\end{tikzpicture}\EndNoteText{چه ‹استاتمنت› ۱ ‹فالس› شود، چه ‹استاتمنت› ۲ ‹ترو›، این ‹سایکل› پایان می‌یابد•}\EndNoteText{پیش از بیرون رفتن این ‹کامند ها› ‹اگزکیوت میشوند›•}\EndNoteText{اگر این ‹استاتمنت› ‹ترو› شود، آنگاه راه قرمز رنگ در پیش گرفته می‌شود و ‹لوپ› زود‌تر از آنچه باید به پایان می‌رسد•}\EndNoteText{اگر ‹استاتمنت› ۲ ‹ترو› شود، آنگاه این ‹کامند ها› دیگر ‹کال نمیشوند›!}

\caption{برون رفت از ❬لوپ❭ پر رنگ شده دو ❬پت❭ دارد: ❬استاتمنت❭ ۱ ❬فالس❭ شود و ❬سایکل❭ ❬اگزکیوت❭ ❬کامند ها❭، مانند هر ❬سایکل❭ دیگری، پایان یابد یا ❬استاتمنت❭ ۲ ❬ترو❭ شود و ❬کامند❭ \code{break} ❬سایکل❭ را بشکند\label{R38}}
\end{Figure}

\begin{Program}
\caption{❬تست❭ اول بودن\label{R39}}

▼
N = int(input())
I = 2
while I < N:
	if N % I == 0:
		break
▲
 اگر \code{N} بر \code{I} ‹پارت› شود، ‹ایمدیت› ‹لوپ› شکسته می‌شود• 
▽
	I += 1
if I != N:
△
 اگر \code{I != N} باشد، بی‌گمان ‹کامند› \code{break} ‹لوپ› را شکسته! زیرا به ‹کانتر› \code{I} هر بار افزوده می‌شد و باید به \code{N} می‌رسید• 
▽
	print("«اول␣نیست»")
else:
△
 اگر \code{I == N} باشد، ‹کامند› \code{break} رخ نداده است و \code{N} هیچگاه ‹پارت› پذیر نبوده است• 
▽
	print("«اول␣هست»")
△
\end{Program}

در ‹پایتون› هم ‹کامند› \code{while} و هم ‹کامند› \code{for} که بررسی شدند می‌توانند ‹پارت› \code{else} داشته باشند:
\begin{quotation}
‹کامند های› پس از \code{else} زمانی ‹کال میشوند› که ‹لوپ› نشکسته و به پایان خود رسیده باشد•
\end{quotation}
\ref{R38 =000648 else} نشان می‌دهد که ‹پارت› \code{else} چگونه کار می‌کند• در \ref{R39 =000628=000627 else} هم یک ‹کامند› \code{while} که ‹پارت› \code{else} دارد ‹یوتیلایز شده›•

\begin{Program}
\caption{❬تست❭ اول بودن با کمک \code{else}\label{R39 =000628=000627 else}}

▼
N = int(input())
I = 2
while I < N:
	if N % I == 0:
		print("«اول␣نیست»")
		break
▲
 اگر \code{N} بر یک \code{I} ‹پارت› شود آنگاه \code{while} زود‌تر شکسته می‌شود و به پایان خود نمی‌رسد؛ 
▽
	I += 1
else:
	print("«اول␣بودش»")
△
 اگر این چنین نشود ‹کامند های› پس از \code{else} ‹کال› می‌شوند•
\end{Program}

\begin{Figure*}
\begin{tikzpicture}
	\matrix
	{
		&|(S)[junction]|\\
		&|(D)[decision]|❬استاتمنت❭ ۱&|(X)[activity, color=blue]|❬کامند هایی❭ که درون ❬پارت❭ \code{else} آمده‌اند\\
		&|(A)[activity]|❬کامند ها❭&|(B)[activity, color=red]|❬کامند❭ \code{break}&|(E)[junction]|\\
		|(N)[activity]|❬کامند ها❭&|(C)[decision]|❬استاتمنت❭ ۲&|(P)[activity, color=red]|❬کامند هایی❭ که پیش از ❬کامند❭ \code{break} آمده‌اند\\
	};
	{[edges]
		\draw (S) -- (D);
		\draw (A) -- (C);
		\draw (D) -- node {❬ترو❭} (A);
		\draw[blue] (D) -- node {❬فالس❭} (X);
		\draw[red] (C) -- node {❬ترو❭} (P);
		\draw (C) -- node {❬فالس❭} (N);
		\draw[blue] (X) -| (E);
		\draw (N) |- (D);
		\draw[red] (P) -- (B);
		\draw[red] (B) -- (E);
	}
	{[highlights]
		\node (F) [fit=(D)(A)(N)(C)] {};
	}
\end{tikzpicture}

\caption{یک ❬لوپ❭ با ❬پارت❭ \code{else}: اگر ❬لوپ❭ شکسته نشود در پایان ❬استاتمنت❭ ۱ ❬فالس❭ شده و ❬کامند های❭ آبی رنگ که درون ❬پارت❭ \code{else} هستند ❬کال میشوند❭؛ اما اگر ❬استاتمنت❭ ۲ ❬ترو❭ شود، ❬لوپ❭ شکسته شده و ❬کامند های❭ قرمز رنگ که پیش از ❬کامند❭ \code{break} نوشته شده‌اند ❬کال میشوند❭\label{R38 =000648 else}}
\end{Figure*}

\subsection{❬کامند❭ \code{continue}}
‹پایتون› همانند برخی ‹لنگویج های› ‹پروگرامینگ› دیگر ‹کامند› \code{continue} هم دارد• این ‹کامند› کم ‹یوزیج› ‹لوپ› \code{while} را از سر می‌گیرد• در \ref{R42} این ‹کامند› ‹یوتیلایز شده›•

\begin{Program}
\caption{❬پرینت❭ کردن ❬نامبر هایی❭ که بر \code{3} یا \code{5} ❬پارت❭ پذیر نیستند\label{R42}}

▼
I = 0
while I < 20: «\label{R43}»
	I += 1
	if I % 3 == 0 or I % 5 == 0:
▲
 اگر \code{I} بر \code{3} یا \code{5} ‹پارت› شود، 
▽
		continue
△
 آنگاه ‹پروگرام› دو‌باره به \ref{R43} می‌رود، 
▽
	print(I)
△
 و این ‹کامند› \code{print(I)} دیگر ‹اگزکیوت نمیشود›•
\end{Program}

------------

\section{❬کامند❭ \code{pass}}
در هر ‹کامند› ‹استراکچرد› مانند \code{if} و \code{while} و \ldots{} باید دست کم یک ‹کامند› دیگر باشد• اگر ‹کامند ها› گفته نشده باشند یا زمان نوشتن آنها نرسیده باشد، آنگاه می‌توان به جای آنها \code{pass} نوشت تا زمان نوشتن آنها برسد• برای ‹اینستنس› ‹کامند› \code{M = float(input("Average:"))} ‹اوریج› را از ‹یوزر› می‌گیرد• اما گفته نشده است ‌دانیم زمانی که \code{M >= 12} است چه باید ‹اگزکیوت کرد›! پس می‌توان نوشت: 
▼
if M >= 12: 	passelse:	UNITS_PERMITTED = 20
▲
\begin{InlinePrograms}

\section{❬پروگرام های❭ ❬اینستنس❭}
در این ‹پارت› چند ‹پروگرام› ‹اینستنس› به همراه ‹ریسپانس› آنها آورده شده‌اند• در این ‹پروگرام ها› آنچه تا اینجا آموزش داده شده ‹یوتیلایز شده›•

\begin{Program}
\caption{❬پرینت❭ کردن ❬سیکونس❭ ❬فیبوناچی❭\label{R44}}

برای نشان دادن ‹سیکونس› ‹فیبوناچی› هم باید کار‌هایی را چندین بار ‹اگزکیوت کرد›• پس در این ‹پروسه› نیز به ‹کامند› \code{while} نیاز است•

▼
A = B = 1«\NewNoteMark»
▲
 \code{A} و \code{B} برابر با \code{1} می‌شوند• 
▽
I = 0
△
 ‹کانتر› \code{I} هم برابر با \code{0} می‌شود• 
▽
while I < 10:
△
 تا زمانی که ‹کانتر› \code{I} کمتر از \code{10} است: 
▽
	print(B, end=" ")
△
 \code{B} ‹پرینت› شده و 
▽
	A, B = A + B, A«\NewNoteMark»
△
 می‌شود• در اینجا یک ‹تاپل› با ‹انتری های› \code{A + B} و \code{A} ‹دولوپ شده› و پس از آن \code{=} کار خود را ‹اگزکیوت میکند›• پس از این ‹کامند› \code{A} و \code{B} یکی روی ‹سیکونس› ‹فیبوناچی› به جلو رفته‌اند! 
▽
	I += 1
△
 به ‹کانتر› \code{I} افزوده می‌شود تا ‹کامند های› درون ‹کامند› \code{while} ده بار ‹اگزکیوت شوند›• \EndNoteText{در ‹پایتون›، مانند هر ‹لنگویج› ‹پروگرامینگ› دیگری، \code{=} از راست به چپ کار می‌کند• پس در اینجا نخست \code{B = 1} شده و پس از آن \code{A = B} می‌شود•}\EndNoteText{‹کامند› \code{A, B = A + B, A} ‹ایکوال› با ‹کامند های› \code{X = A + B;}، \code{Y = A;}، \code{A = X;}، و \code{B = Y;} در ‹لنگویج ـی› مانند ‹سی-پی-پی› است• (\ref{R17} را ببینید•)}

‹ریسپانس› این ‹پروگرام› 
⧨
1 1 2 3 5 8 13 21 34 55
◭
 خواهد بود•
\end{Program}

\begin{Program}
\caption{❬دیاگرام❭ یک سنگ پرتاب شده به بالا\label{R45}}

یک سنگ پرتاب شده به بالا در زمان $t$ به اندازه
\[
-\frac{1}{2}gt^{2}+vt
\]
بالا رفته است•

▼
V = 30	# «از کاربر گرفته شود» V «بهتر است»
G = 9.8	# «گرانش زمین»
T = 0	# «زمان پرتاب کردن»
while T <= 5:
▲
 تا زمانی که \code{T <= 5} است؛ 
▽
	Y = -0.5 * G * T**2 + V * T
△
 \code{Y} بدست آمده و 
▽
	print(T, Y)
△
 هم \code{T} و \code{Y} هم ‹پرینت› می‌شوند• 
▽
	T += 0.5
△
 در اینجا کمی به \code{T} افزوده می‌شود

‹ریسپانس› این ‹پروگرام› 
⧨
0 0.0
0.5 13.775
1.0 25.1
1.5 33.975
2.0 40.4
2.5 44.375
3.0 45.9
3.5 44.974999999999994«\NewNoteMark»
4.0 41.599999999999994
4.5 35.77499999999999
5.0 27.499999999999986
◭
 خواهد بود•\EndNoteText{هیچ ‹هاردور ی› نمی‌تواند ‹دسیمال ها› را به درستی نگهداری کند• برای بیشتر دانستن \ref{=000628=00062E=000634: =0006A9=000631=000627=000646 =000627=000639=00062F=000627=00062F} را بخوانید• این بار هم نگران نباشید! در \ref{=000628=000631=000646=000627=000645=000647: =00067E=000631 =0006A9=000631=00062F=000646 =000628=00062E=000634=0006CC =000627=000632 =0006CC=0006A9 =000631=000634=00062A=000647} ‹متد ـی› برای گرد کردن ‹ریسپانس ها› آمده است•}

با کمک ‹پکیج› \code{matplotlib} می‌توان ‹ریسپانس› یک ‹پروگرام› را همانند یک ‹دیاگرام› کشید• برای ‹اینستنس› \ref{R46} از روی ‹ریسپانس› همین ‹پروگرام› کشیده شده است• برای ‹اگزکیوت› بیشتر ‹پروسس ها› ‹پایتون› چندین ‹پکیج› دارد• اما در کشیدن ‹دیاگرام ها› ‹پکیج› \code{matplotlib} هماوردی ندارد! در \ref{=000628=00062E=000634: =000628=000633=00062A=000647=00200C=000647=000627} به این ‹پکیج› خواهیم پرداخت•
\end{Program}

\begin{Figure}
\begin{tikzpicture}
	\begin{axis}[xlabel=$t$, ylabel=$y$, xmax=6, ymax=50]
	\addplot coordinates
	{
		(0.0,  0.00)
		(0.5, 13.78)
		(1.0, 25.10)
		(1.5, 33.98)
		(2.0, 40.40)
		(2.5, 44.38)
		(3.0, 45.90)
		(3.5, 44.97)
		(4.0, 41.60)
		(4.5, 35.77)
		(5.0, 27.50)
	};
	\end{axis}
\end{tikzpicture}

\caption{❬دیاگرام ی❭ که ❬پکیج❭ \code{matplotlib} از روی ❬ریسپانس❭ \ref{R45} ❬دولوپ کرده❭ است\label{R46}}
\end{Figure}

\begin{Program}
\caption{جدول ضرب\label{R47}}

در ‹پایتون›، همانند دیگر ‹لنگویج های› ‹پروگرامینگ›، می‌توان ‹لوپ های› ‹نستد› نیز داشت• در این ‹پروگرام› یک ‹کامند› \code{while} درون دیگری نوشته شده است!

در این ‹پروگرام› \code{I} ‹نامبر› ‹روو› و \code{J} ‹نامبر› ‹کالمن› است• 
▼
I = 1
while I < 10:
▲
 ‹کامند های› درون این ‹کامند› \code{while} تا زمانی که \code{I < 10} است ‹اگزکیوت میشوند›• 
▽
	J = 1
	while J < 10:
		if I * J < 10:
			print("", end«\NewNoteMark»=" ")
△
 اگر \code{I * J < 10} باشد، آنگاه \code{I * J} یک ‹دیجیت ـی› است و جای کمتری از یک دو ‹دیجیت ـی› می‌گیرد• با ‹پرینت› کردن یک \likestring{ } پیش از \code{I * J} ‹ریسپانس› زیبا‌تر می‌شود• 
▽
		print(I * J, end=" ")
		J += 1
	print()
△
 تا اینجا یک ‹روو› ‹پرینت› شده است• این \code{print} ‹لاین› کنونی را پایان می‌دهد• 
▽
	I += 1
△
 در اینجا به \code{I} افزوده می‌شود•

‹ریسپانس› این ‹پروگرام› 
⧨
 1  2  3  4  5  6  7  8  9 
 2  4  6  8 10 12 14 16 18 
 3  6  9 12 15 18 21 24 27 
 4  8 12 16 20 24 28 32 36 
 5 10 15 20 25 30 35 40 45 
 6 12 18 24 30 36 42 48 54 
 7 14 21 28 35 42 49 56 63 
 8 16 24 32 40 48 56 64 72 
 9 18 27 36 45 54 63 72 81 
◭
 خواهد بود•\EndNoteText{\code{end} آنچه پس از نشان دادن ‹دیتا ها› باید ‹پرینت› شود است• اگر نوشته نشده باشد، برابر با \likestring{\textbackslash n} می‌شود•}
\end{Program}

\begin{Program}
\caption{❬دولوپ❭ جدول ضرب\label{R48}}

نه تنها ‹کامند› \code{while} ‹نستد› که ‹کامند› \code{for} ‹نستد› هم می‌توان ‹دولوپ کرد›• در این ‹پروگرام› یک ‹کامند› \code{for} درون دیگری نوشته شده است•

▼
for I in range(1, 10):
	for J in range(1, 10):
		if I * J < 10:
			print("0", end="")
▲
 اگر \code{I * J} کمتر از \code{10} باشد، آنگاه یک \code{"0"} پیش از نمایش آن ‹پرینت› می‌شود تا ‹ریسپانس› زیبا‌تر شود• 
▽
		print(I * J, end=" ")
	print()
△

‹ریسپانس› این ‹پروگرام› 
⧨
01 02 03 04 05 06 07 08 09 
02 04 06 08 10 12 14 16 18 
03 06 09 12 15 18 21 24 27 
04 08 12 16 20 24 28 32 36 
05 10 15 20 25 30 35 40 45 
06 12 18 24 30 36 42 48 54 
07 14 21 28 35 42 49 56 63 
08 16 24 32 40 48 56 64 72 
09 18 27 36 45 54 63 72 81 
◭
 خواهد بود•

\ref{R47} با اینکه ‹کامند های› بیشتری دارد اما همین ‹ریسپانس› را نشان می‌دهد• در بیشتر ‹پروگرام ها› و در بیشتر ‹لنگویج های› ‹پروگرامینگ› ‹یوتیلایز› ‹کامند› \code{for} ‹پروگرام› را کوتاه‌تر می‌کند؛ اما نباید این آمار دستاویزی برای بیش از اندازه ‹یوتیلایز› ‹کامند› \code{for} شود!
\end{Program}

\begin{Program}
\caption{❬پسس❭ از روی یک ❬استرینگ❭\label{R49}}

در ‹پایتون› یک ‹استرینگ› هم ‹سیکونس› یا ‹لیست ـی› از ‹کاراکتر ها› است• پس با کمک \code{for} هم می‌توان به ‹کاراکتر های› یک ‹استرینگ› ‹اکسس› داشت• برای ‹اینستنس› ‹ریسپانس› 
▼
W = 1
S = "Programming with Python 3"
for C in S:
	if C == " ":
▲
 هر بار که ‹کاراکتر› \code{" "} دیده شود، 
▽
		W += 1
△
 یکی به ‹کانتر› \code{W} افزوده می‌شود• 
▽
print("Number of words =", W) 
△

‹ریسپانس› این ‹پروگرام› 
⧨
Number of words = 4
◭
 خواهد بود•

در اینجا آموزش ‹پسس› از روی ‹استرینگ› با کمک \code{for} ‹ریکوایرمنت› ما بود؛ اگر نه ‹متد› بسیار ساده‌تر و ‹پایتونیک تری› هم برای ‹اگزکیوت› همین کار در \ref{=000628=00062E=000634: =000631=000634=00062A=000647=00200C=000647=000627} آمده است•
\end{Program}

\begin{Program}
\caption{❬پسس❭ از روی ❬کیی های❭ درون یک ❬دیکشنری❭\label{R50}}

یک ‹دیکشنری› ‹مپ ـی› از ‹کیی ها› به ‹ولیو ها› است• اما ‹فانکشن› \code{__iter__()} این ‹دیتا› ‹استراکچر› هر بار یکی از ‹کیی های› درون آن را ‹ریترن میکند› و نه یکی از ‹ولیو هایش› را! پس، ‹پسس› از روی یک ‹دیکشنری›، ‹پسس› از روی ‹کیی های› آن خواهد بود و نه از روی ‹ولیو های› درون آن• برای ‹اینستنس› اگر 
▼
B = {
		"«نام»": "«بهمن»",
		"«نشانی»": "«کاشان»",
		"«میانگین»": 18.23
	}
▲
 باشد، آنگاه 
▽
for K in B:
△
 در اینجا ‹کامند› \code{for} هر بار یکی از ‹کیی های› درون ‹دیکشنری› \code{B} را درون ‹آیدنتیفایر› \code{K} می‌گذارد• پس ‹آیدنتیفایر› \code{K} برابر با \likestring{نام}، \likestring{نشانی}، و \likestring{میانگین} می‌شود• 
▽
	print(K, "=", B[K])
△

‹ریسپانس› این ‹پروگرام› می‌تواند\EndNote{‹انتری های› درون ‹دیکشنری› هیچ ‹اوردر ـی› ندارند• هنگام ‹پسس› از روی این ‹دیتا› ‹استراکچر› پس و پیش شدن ‹انتری ها› همواره شدنی است! بی‌گمان، در هر ‹پسس› ‹انتری ها› خواهند آمد اما نباید ‹اوردر› آنها را یکسان دانست یا ‹پریدیکت› کرد و بر ‹بیس› آن چیزی نوشت•} 
⧩
«بهمن» = «نام»
18.23 = «میانگین»
«کاشان» = «نشانی»
◮
 باشد•
\end{Program}

\begin{Program}
\caption{افتادن در یک یا چند درس\label{R51}}

‹کامند های› \code{break} و \code{continue} را می‌توان برای شکستن یا از سر گرفتن \code{for} هم ‹یوتیلایز کرد›• همانند ‹کامند› \code{while}، ‹کامند› \code{for} هم می‌تواند یک ‹پارت› \code{else} داشته باشد: ‹کامند های› آمده در این ‹پارت› زمانی ‹اگزکیوت میشوند› که \code{for} به پایان خود رسیده باشد و با \code{break} شکسته نشده باشد• در اینجا از شکسته شدن \code{for} برای دانستن اینکه نمره‌ای کمتر از \code{10} است یا نه کمک گرفته شده است•

▼
S = [14, 12.2, 11.8, 18]
for A in S:
▲
 \code{A} هر بار یکی از ‹انتری های› \code{S} می‌شود• 
▽
	if A < 10:
△
 اگر \code{A} کمتر از \code{10} باشد، آنگاه 
▽
		print("«درسی␣را␣افتاده‌اید!»")
△
 یک ‹مسیج› ‹آلرت› ‹پرینت› شده؛ و 
▽
		break
△
 \code{for} شکسته می‌شود و زود‌تر از آنچه باید به پایان می‌رسد• 
▽
else:
	print("«هیچ␣درسی␣را␣نیافتاده‌اید»")
△
 اما اگر همه ‹انتری ها› بیشتر یا برابر با \code{10} باشند، آنگاه \code{for} به پایان خود می‌رسد و ‹کامند های› پس از این \code{else} ‹کال میشوند›•

‹ریسپانس› این ‹پروگرام› 
⧩
«هیچ درسی را نیافتاده‌اید»
◮
 خواهد بود•
\end{Program}
\end{InlinePrograms}
\backmatter
\printbibliography

\end{document}
